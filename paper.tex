\documentclass[11pt]{article}

\usepackage{notation/modes}
\usepackage{notation/judgments}
\usepackage{notation/common}
\usepackage{notation/abts}
\usepackage{refinements}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{leftidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{catchfilebetweentags}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifdraft}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{scalerel}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage[length=.5]{tikzpfeile}
\usepackage{url}
\usepackage[titletoc,title]{appendix}
\usepackage{todonotes}

%% fonts
\usepackage{pxfonts}
\usepackage{eulervm}
\usepackage[
  activate={true,nocompatibility},
  kerning=true,
  spacing=true,
  tracking=true
]{microtype}
\usepackage{bbold}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{notation}
\newtheorem{notation}[thm]{Notation}
\newtheorem*{notation*}{Notation}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\newtheorem*{remark*}{Remark}
\numberwithin{equation}{section}

\newcommand\HPGenJ[4]{\vert^{\IMode{#1}\parallel\IMode{#2}}_{\IMode{#3}}\; #4}

\newcommand\Pow[1]{\wp\left(#1\right)}

\newcommand\MapsTo[2]{\IMode{#1}\mapsto\OMode{#2}}
\newcommand\IsSubsetEq[2]{\IMode{#1}\subseteq\IMode{#2}}

\newcommand\IsAbtUnmoded[5]{
  #1\triangleright%
  #2\parallel%
  #3\vdash%
  #4:\OMode{#5}%
}

\newcommand\TyBase[1]{\mathtt{Base}_{#1}}
\newcommand\TyTop[1]{\top_{#1}}
\newcommand\TyBot[1]{\bot_{#1}}

\newcommand\EvalN[5]{\IMode{#1}\parallel\IMode{#4}\Downarrow^{\OMode{#3}}_{\IMode{#2}}\OMode{#5}}
\newcommand\Eval[4]{\EvalN{#1}{#2}{}{#3}{#4}}
\newcommand\Exprs{\mathbf{E}}
\newcommand\Values{\mathbf{V}}
\newcommand\BTms{\mathbf{B}}
\newcommand\Naturals{\mathbb{N}}
\newcommand\NaturalsPsh{\mathcal{N}}

\tikzset{
  commutative diagrams/.cd,
  arrow style = tikz,
  diagrams = {>=latex},
}
\tikzstyle{displays} = [
  ->,
  >=open triangle 45,
]

\begin{document}

\title{Type Refinements for the Working Class}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

There are two conflicting views which bedevil any discussion of the nature of
type theory. First, there is the notion of type theory as an extension or
generalization of universal algebra to support interdependency of sorts and
operations, possibly subject to an arbitrary equational theory
\cite{cartmell:1986, dybjer:1996}; we will call this \emph{formal type theory}.
Typing, in such a setting, is a mere matter of grammar and is nearly always
decidable. In hindsight, we may observe that this is the sort of type theory
which Martin-L\"of first proposed in 1972~\cite{martin-lof:1972}, even if we
will admit that this was not the intention at the time. A model for such a type
theory is usually given by interpreting the types or sorts as presheaves or
sheaves over contexts of hypotheses, and as such, a proof theoretic
interpretation of the hypothetical judgment is possible.

Secondly, there is the view of type theory as semi-formal theory of
constructions for the Brouwer-Heyting-Kolmogorov interpretation of
intuitionistic mathematical language, which we will call \emph{behavioral} or
\emph{semantic type theory}. The most widely known development of this program
is Martin-L\"of's 1979 ``extensional'' type theory~\cite{martin-lof:1979,
martin-lof:1984}, but we must give priority to Dana Scott for inventing this
line of research in 1970 with his prophetic report, \emph{Constructive
Validity}~\cite{scott:1970}. Since the 1980s, behavioral type theory has been
developed much further in the Nuprl family~\cite{constable:1986} of proof
assistants, including MetaPRL~\cite{hickey:2003} and JonPRL~\cite{jonprl:2015}.

Martin-L\"of's key innovation was the commitment to pervasive functionality
(extensionality) as part of the \emph{definitions} of the judgments and the
types, in contrast to the state of affairs in formal type theory where
functionality is a metatheorem which must be shown to obtain, based on the
(somewhat arbitrary) equational theory which has been imposed. Furthermore,
models for behavioral type theory interpret the types as partial equivalence
relations (PERs) on only closed terms, and the meaning of the hypothetical
judgment is defined separately and uniformly in the logical relations style.

Our position is that these views of type theory are not in conflict, but rather
describe two distinct layers in a single, harmonious system. From this
perspective, formal type theories can do little more than negotiate matters of
grammar, and therefore may serve as a linguistic framework for mathematical
expression, being responsible for the management of variable binding and
substitution. On the other hand, mathematical objects find
\emph{meaning} in their extension within the behavioral type theory, and are
subject to an extensional equality.

The types of the semantic theory can then be said to \emph{refine} the types of
the syntactic theory~\cite{harper-davies:2014, harper-duff:2015, harper:2016},
both by placing restrictions on membership and by coarsening equivalence. Thus
far, most developments of behavioral type theory have been built on a
\emph{unityped} syntactic framework, and so the relation to type refinements
has been difficult to see.

In this paper, we contribute a full theory of behavioral refinements over
multi-sorted nominal abstract binding trees with symbolic parameters, a simple
but interesting formal type theory~\cite{harper:2016, sterling-morrison:2015};
this hybrid system allows the deployment of a Nuprl-style type theory over any
signature of sorts and operators.

Owing to the \emph{nominal} aspect of our abstract binding tree (abt) framework, this
development constitutes a possible alternative to Allen's semantics for
unguessable atoms in Nuprl~\cite{allen:2006}; Allen proposed a
``supervaluation'' semantics, that explained sequents involving atoms (symbols)
by quantifying over the possible ways to interpret the class of atoms. Our
semantics seem to be a more direct and concrete way to approach the problem,
which is licensed in part by the nominal character of the abt framework.

\ifcolored%
\paragraph{Colors}
In this paper, we hint at the \emph{modes} of judgments and
assertions~\cite{harper:2016} using colors, marking inputs with
$\IMode{\texttt{blue}}$ and outputs with $\OMode{\texttt{red}}$. As a rule of
thumb, inputs are things which are supplied when checking the correctness of a
judgment, and outputs are things which are synthesized in the process. \fi


\section{Abstract Binding Trees and Symbols}

See~\cite{sterling-morrison:2015} for the development of abstract binding trees
with symbols. \todo[inline]{give a brief description of the framework, and present its
rules.}

\section{Generalized Predicative Foundations}

Before we continue, it makes sense to remark briefly on the strength of the
mathematical foundations that we are assuming for the development of our
framework. As in Martin-L\"of's meaning-theoretic judgmental method, our
apparatus is meant to be understood in a constructive and predicative
metatheory; therefore, by $\Sets$, we do not mean the classical category of
sets, but rather the intuitionistic one, which lacks the powerset
operation.

Therefore, in our setting, $\Sets$ is not an elementary topos, and nor is any
category of $\Sets$-valued (pre)sheaves. However, for a category of classes
$\Classes$, we can express a power class operation
$\Define{\Pow{X}}{\MkSet{Y\mid Y\subseteq X, Y\in\Sets}}$ which gives the
proper class of sub\emph{sets} of a class $X$ \cite{gambino:2002}.

A category of $\Classes$-valued presheaves then is a $\Pi W M$-pretopos (a
predicative topos with dependent function objects, wellfounded trees, and
non-wellfounded trees); such a pretopos also admits a large subobject
classifier $\Omega(c)$, defined as the class of small sieves on
$c$,\footnote{A sieve $S$ on $c$ is a subobject of the Yoneda
embedding $\Yoneda{c}$, and $S$ is \emph{small} if $S(d)$ is a set for every
stage $d$.} whence we can form the large power object
$\Define{\Pow{X}}{\Omega^X}$ for any object $X$.

In practice, the shift to a predicative topos with a large power object was a
mere technical nuisance, as all the constructions we needed to perform carried
over perfectly to this setting. For the remainder of this paper, we assume the
semantic universe $\Define{\SemU}{\Classes^\SCtx}$, the category of
copresheaves on symbol contexts. Every judgment $\mathcal{J}$ which we define
in this paper should be understood as such a copresheaf, which is at each stage
$\Upsilon$ the class of derivations of $\mathcal{J}$ using symbols in
$\Upsilon$; we will also make use of \emph{internal} forms of judgment, which
are sections of $\Pow{X}$ for some object $X$.

Our purpose in fixing a semantic universe is emphatically \emph{not} to give an
interpretation or model of type theory inside set theory, though it is possible
to read our construction in this metamathematical light---however, the
vocabulary of the pretopos $\SemU$ gives us a perspicuous notation in which to
propound what we consider to be an informal (pre-mathematical) meaning
explanation in the sense of Heyting~\cite{heyting:1956} and
Martin-L\"of~\cite{martin-lof:1979}.
\footnote{
  Both Gambino~\cite{gambino:2002} and Dybjer~\cite{dybjer:2012} give lucid
  explanations of the distinction between \emph{meaning theory} and \emph{model theory}.
}

\section{Behavioral Refinements}

Fixing a signature $\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$ in the abt
framework, we will define the notion of behavioral refinement by propounding
several judgments and their semantical explanations. Let us first define the
copresheaf of $\tau$-sorted expressions, $\Exprs_\tau$ as follows
\[
  \Define{
    \Exprs_\tau(\Upsilon\parallel\Gamma)
  }{
    \MkSet{M \mid \IsAbtUnmoded{\cdot}{\Upsilon}{\Gamma}{M}{\tau}}
  }
\]

We will also write $\Exprs_\tau$ for the copresheaf $\Exprs_\tau(-\parallel\cdot)$ on $\SCtx$.

\subsection{Parametric Refinement}
\label{sec:parametric-refinement}

The first judgment that will concern us is called \emph{parametric refinement},
$\Refines{\Upsilon}{\phi}{\tau}$, which means that $\phi$ refines the sort
$\tau$ under the symbolic parameters $\Upsilon$. We define this judgment
through a meaning explanation in the style of Martin-L\"of as follows:

\newcommand\RefEquate[4]{#1\{\IMode{#2}\}\left(\IMode{#3},\IMode{#4}\right)}

\begin{definition}
  To know $\Refines{\Upsilon}{\phi}{\tau}$ (presupposing $\IsSymCtx{\Upsilon}$
  and $\IsSort{\tau}$) is to know, for any
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}
, what it means for any $\Member{M,N}{\Exprs_\tau(\Upsilon')}$ to be equated by
  $\phi$ (written $\RefEquate{\phi}{\rho}{M}{N}$), such that
  $\RefEquate{\phi}{\rho}{-}{-}$ is a partial equivalence relation (PER) on
  $\Exprs_\tau(\Upsilon')$. Morever, that for any
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon'}\arrow[r,hook,"\IMode{\rho'}"] &\IMode{\Upsilon''}
  \end{tikzcd}
,
  from $\RefEquate{\phi}{\rho}{M}{N}$ we may conclude
  $\RefEquate{\phi}{\rho'\circ\rho}{\Rename{\rho'}{M}}{\Rename{\rho'}{N}}$.
\end{definition}

Then, we say that $\phi$ \emph{globally refines} $\tau$ (written
$\GloballyRefines{\phi}{\tau}$) when we have $\Refines{\cdot}{\phi}{\tau}$.
Furthermore, when $\Refines{\Upsilon}{\phi}{\tau}$, for any renaming
\begin{tikzcd}[cramped]
  \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
\end{tikzcd}
we can clearly define a new refinement $\Refines{\Upsilon'}{\Rename{\rho}{\phi}}{\tau}$.

\begin{remark}\label{rem:internal}

  At this point, it should be noted that this is very similar to the semantical
  explanation of typehood given in~\cite{martin-lof:1979}, except that we have
  generalized it to a multi-sorted setting, and that we have fibred the entire
  apparatus over collections $\Upsilon$ of symbols; furthermore, whereas
  Martin-L\"of defines types in terms of evaluation to canonical form, we have
  remained agnostic on this point as far as refinements are concerned. We will
  come back to the notions of \emph{type} and \emph{computation} in
  section~\ref{sec:ctt}.

  In fact, the complexity of the above meaning explanation is an artifact of
  the pointwise style in which we have expressed it. Considered internally to
  the semantic universe $\SemU$, a refinement is merely a section of the
  object of $\Exprs_\tau$-PERs $\PERs{\Exprs_\tau}$, defined
  internally as a subobject of $\Pow{\Exprs_\tau\times\Exprs_\tau}$:
  \[
    \Define{
      \PERs{X}
    }{
      \{ \phi : \Pow{X\times X}
         \mid
         symmetric(\phi)
         \land transitive(\phi)
      \}
    }
  \]

  So, $\Refines{\Upsilon}{\phi}{\tau}$ obtains just when we have
  $\Member{\phi}{\PERs{\Exprs_\tau}(\Upsilon)}$. The benefit of explaining such
  judgments as copresheaves is that we do not need to deal with
  the complexities of quantifying over renamings, since this is implicit in the
  definition of the exponential of presheaves, where
  $\Define{\Coyoneda{\Upsilon}}{\Upsilon\inj-}$ is the co-Yoneda embedding:
  \begin{align*}
    \ADefine{
      B^A(\Upsilon)
    }{
      \Hom{\SemU}{
        \Coyoneda{\Upsilon}\times A
      }{
        B
      }
    }\\
    &\cong
    \OMode{
      \int_{\Upsilon'}
      (\Upsilon\inj\Upsilon')
      \implies
      {B(\Upsilon')}^{A(\Upsilon')}
    }
  \end{align*}

  It should be noted that PERs can be understood as 0-semigroupoids. In other
  words, these are 1-groupoids without identity morphisms and without coherence
  laws regarding composition and inverse operations. This distinction is
  especially relevant in formal type theory where groupoids ``one dimension
  down'' are not sets but setoids (i.e., groupoids sans coherence). Thus, a PER
  can formally be thought of as a kind of partial setoid that facilitates
  constructions on subsets in addition to quotients. \todo[inline]{Say something
    about internal (semi)-groupoids?}

\end{remark}

\subsubsection{Order and Equality of Parametric Refinements}

We will write $\IsSubrefinement{\Upsilon}{\phi}{\psi}{\tau}$ to mean that $\phi$ is
a \emph{subrefinement} of $\psi$.

\begin{definition}

  To know $\IsSubrefinement{\Upsilon}{\phi}{\psi}{\tau}$ (presupposing
  $\Refines{\Upsilon}{\phi}{\tau}$ and $\Refines{\Upsilon}{\psi}{\tau}$), is
  to know, for any renamings
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r, hook, "\IMode{\rho}"]
    & \IMode{\Upsilon'} \arrow[r, hook, "\IMode{\rho'}"]
    & \IMode{\Upsilon''}
  \end{tikzcd}
  , that from $\RefEquate{\phi}{\rho}{M}{N}$ you can conclude
  $\RefEquate{\psi}{\rho'\circ\rho}{\Rename{\rho'}{M}}{\Rename{\rho'}{N}}$ for any
  $\Member{M,N}{\Exprs_\tau(\Upsilon')}$.

\end{definition}

Two refinements are equal when they denote the same PER.\@That is, we have
$\EqRefines{\Upsilon}{\phi}{\psi}{\tau}$ just when both
$\IsSubrefinement{\Upsilon}{\phi}{\psi}{\tau}$ and
$\IsSubrefinement{\Upsilon}{\psi}{\phi}{\tau}$.

\subsection{Parametric Equality}

The primary judgment concerning refinements is the parametric equality,
$\RMemEq{\Upsilon}{M}{N}{\phi}$, which presupposes
$\Refines{\Upsilon'}{\phi}{\tau}$ for some $\Upsilon'$ such that we have
\begin{tikzcd}[cramped, sep = small]
  \IMode{\Upsilon'} \arrow[r, hook, "\IMode{\rho}"] &\IMode{\Upsilon}
\end{tikzcd}
, and $\Member{M,N}{\Exprs_\tau(\Upsilon)}$. The meaning of this judgment is
that $M$ and $N$ are identified by $\phi$ at $\Upsilon$:
\[
  \infer{
    \RMemEq{\Upsilon}{M}{N}{\phi}
  }{
    \RefEquate{\phi}{\rho}{M}{N}
  }
\]

\subsection{Functional Refinement}

\newcommand\RefinesCtxNil{\sqsubset^\star_{\mathtt{nil}}}
\newcommand\RefinesCtxSnoc{\sqsubset^\star_{\mathtt{snoc}}}
\newcommand\PFunRefNil{\vDash^\sqsubset_{\mathtt{nil}}}
\newcommand\PFunRefSnoc{\vDash^\sqsubset_{\mathtt{snoc}}}

Next, we define functional refinement
$\FEqRefines{\Upsilon}{\Psi}{\phi}{\psi}{\tau}$ in terms of parametric refinement,
simultaneously with parametric context refinement
$\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$ and functional equality
$\FRMemEq{\Upsilon}{\Psi}{M}{N}{\phi}$. We will write
$\FRefines{\Upsilon}{\Psi}{\phi}{\tau}$ as a shorthand for
$\FEqRefines{\Upsilon}{\Psi}{\phi}{\phi}{\tau}$.

\newcommand\DefRefinesCtxNil[1]{
  \infer[\RefinesCtxNil]{
    \RefinesCtx{#1}{\cdot}{\cdot}
  }{
  }
}
\newcommand\DefRefinesCtxSnoc[6]{
  \infer[\RefinesCtxSnoc]{
    \RefinesCtx{#1}{#2,#3:#4}{#5,#3:#6}
  }{
    \RefinesCtx{#1}{#2}{#5} &
    \FRefines{#1}{#2}{#4}{#6}
  }
}

Parametric context refinement $\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$ shall be
defined as follows, presupposing $\IsSymCtx{\Upsilon}$ and
$\IsVarCtx{\Gamma}$:
\begin{gather*}
  \DefRefinesCtxNil{\Upsilon}\qquad
  \DefRefinesCtxSnoc{\Upsilon}{\Psi}{x}{\phi}{\Gamma}{\tau}
\end{gather*}

For a context refinement $\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$ and a renaming
\begin{tikzcd}[cramped]
  \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
\end{tikzcd}
, we can define a new context refinement
$\RefinesCtx{\Upsilon'}{\Rename{\rho}{\Psi}}{\Gamma}$ by applying $\rho$ pointwise at
each of the sort refinements in the context.

Functional refinement $\FEqRefines{\Upsilon}{\Psi}{\phi}{\psi}{\tau}$ presupposes
$\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$ and $\IsSort{\tau}$, and is explained by
induction on the evidence for its first presupposition.

\paragraph{Case} $\DefRefinesCtxNil{\Upsilon}$.
\[
  \infer[\PFunRefNil]{
    \FEqRefines{\Upsilon}{\cdot}{\phi}{\psi}{\tau}
  }{
    \EqRefines{\Upsilon}{\phi}{\psi}{\tau}
  }
\]

\paragraph{Case} $\DefRefinesCtxSnoc{\Upsilon}{\Psi}{x}{\chi}{\Gamma}{\sigma}$.

\begin{quote}
  To know $\FEqRefines{\Upsilon}{\Psi,x:\chi}{\phi}{\psi}{\tau}$ is to know, for any renaming
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}
  and closed terms $\Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}$, that from
  $\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}$, you can conclude
  $\FEqRefines{\Upsilon'}{\Rename{\rho}{\Psi}}{\Subst{M_0}{x}{\Rename{\rho}{\phi}}}{\Subst{M_1}{x}{\Rename{\rho}{\psi}}}{\tau}$.
  In other words:
  %
  \[
    \infer[\PFunRefSnoc]{
      \FEqRefines{\Upsilon}{\Psi,x:\chi}{\phi}{\psi}{\tau}
    }{
      \begin{array}{l}
        \forall
        \begin{tikzcd}[cramped, ampersand replacement = \&]
          \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
        \end{tikzcd}
        .\ \forall \Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}.\\
        \left(\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}\right)\\
        \quad\implies
        \left(\FEqRefines{\Upsilon'}{\Rename{\rho}{\Psi}}{\Subst{M_0}{x}{\Rename{\rho}{\phi}}}{\Subst{M_1}{x}{\Rename{\rho}{\psi}}}{\tau}\right)
      \end{array}
    }
  \]
\end{quote}


\subsection{Functional Equality}

\newcommand\PFunEqNil{\vDash^=_{\mathtt{nil}}}
\newcommand\PFunEqSnoc{\vDash^=_{\mathtt{snoc}}}

Functional equality $\FRMemEq{\Upsilon}{\Psi}{N_0}{N_1}{\phi}$ presupposes
$\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$, $\FRefines{\Upsilon}{\Psi}{\phi}{\tau}$,
and $\Member{N_0,N_1}{\Exprs_\tau(\Upsilon\parallel\Gamma)}$; this judgment is defined by
induction on the evidence for the first presupposition
$\RefinesCtx{\Upsilon}{\Psi}{\Gamma}$:


\paragraph{Case} $\DefRefinesCtxNil{\Upsilon}$.
\[
  \infer[\PFunEqNil]{
    \FRMemEq{\Upsilon}{\cdot}{N_0}{N_1}{\phi}
  }{
    \RMemEq{\Upsilon}{N_0}{N_1}{\phi}
  }
\]

\paragraph{Case} $\DefRefinesCtxSnoc{\Upsilon}{\Psi}{x}{\chi}{\Gamma}{\sigma}$.
\begin{quote}
  To know $\FRMemEq{\Upsilon}{\Psi,x:\chi}{N_0}{N_1}{\phi}$ is to know, for any renaming
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}
  and closed terms $\Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}$, that from
  $\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}$, you can conclude
  $\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{\Subst{M_0}{x}{\Rename{\rho}{N_0}}}{\Subst{M_1}{x}{\Rename{\rho}{N_1}}}{\Subst{M_0}{x}{\Rename{\rho}{\phi}}}$.
  In other words:
  %
  \[
    \infer[\PFunEqSnoc]{
      \FRMemEq{\Upsilon}{\Psi,x:\psi}{N_0}{N_1}{\phi}
    }{
      \begin{array}{l}
        \forall
        \begin{tikzcd}[cramped, ampersand replacement = \&]
          \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
        \end{tikzcd}
        .\ \forall \Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}.\\
        \left(\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}\right)\\
        \quad\implies
        \left(%
          \FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{%
            \Subst{M_0}{x}{\Rename{\rho}{N_0}}
          }{%
            \Subst{M_1}{x}{\Rename{\rho}{N_1}}%
          }{\Subst{M_0}{x}{\Rename{\rho}{\phi}}
          }%
        \right)
      \end{array}
    }
  \]
\end{quote}

\section{Constructions on Refinements}

Refinements can be arranged in a partial order via the
$\IsSubrefinement{\Upsilon}{\phi}{\psi}{\tau}$ judgment, and admit a lattice structure
at any sort $\tau$.

We have the bottom refinement $\GloballyRefines{\TyBot{\tau}}{\tau}$, which
simply contains no elements. Next, the top refinement
$\GloballyRefines{\TyTop{\tau}}{\tau}$ identifies all terms
$\Member{M,N}{\Exprs_\tau(\Upsilon)}$.  The join (union)
$\Refines{\Upsilon}{\phi\cup\psi}{\tau}$ of two refinements
$\Refines{\Upsilon}{\phi}{\tau}$ and $\Refines{\Upsilon}{\psi}{\tau}$ is defined as
follows, for any
\begin{tikzcd}[cramped, ampersand replacement = \&]
  \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
\end{tikzcd}:

\begin{gather*}
  \infer{
    \RMemEq{\Upsilon'}{M}{N}{\phi\cup\psi}
  }{
    \RMemEq{\Upsilon'}{M}{N}{\phi}
  }\qquad
  \infer{
    \RMemEq{\Upsilon'}{M}{N}{\phi\cup\psi}
  }{
    \RMemEq{\Upsilon'}{M}{N}{\psi}
  }
\end{gather*}

Finally the meet (intersection) $\Refines{\Upsilon}{\phi\cap\psi}{\tau}$ of two refinements
$\Refines{\Upsilon}{\phi}{\tau}$ and $\Refines{\Upsilon}{\psi}{\tau}$ is defined
dually:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{\phi\cap\psi}
  }{
    \RMemEq{\Upsilon'}{M}{N}{\phi} &
    \RMemEq{\Upsilon'}{M}{N}{\psi}
  }
\]

It is trivial to verify that these constructions on refinements give rise to a
lattice.

\begin{remark}
  Observe that \emph{definition} of a refinement
  $\Refines{\Upsilon}{\phi}{\tau}$ is given in terms of an arbitrary
  $\Upsilon'$ that is related to $\Upsilon$ by a renaming. This is because
  $\Upsilon$ is the stage at which the refinement has come into being, but the
  definition of the refinement must be applicable at all subsequent stages.
\end{remark}

\subsection{Families of Refinements}

Given a family of refinements (i.e. a functional refinement)
$\FRefines{\Upsilon}{x:\phi}{\psi}{\tau}$ such that
$\Refines{\Upsilon}{\phi}{\sigma}$, including the family intersection, the
dependent intersection, the family union, and the set comprehension.

\paragraph{Family intersection}
The intersection $\Refines{\Upsilon}{\bigcap_{(x:\phi)}\psi}{\tau}$ of a family
of refinements is defined by the following rule, for any
\begin{tikzcd}[cramped, ampersand replacement = \&]
  \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
\end{tikzcd}:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{
      \bigcap_{(x:\phi)}\psi
    }
  }{
    \FRMemEq{\Upsilon'}{x:\phi}{M}{N}{\Subst{M}{x}{\psi}}
  }
\]

The intersection of a family of refinements is a kind of uniform universal
quantification, in the sense that the terms themselves bear no trace of the
quantification, but are guaranteed in the metalogic to be related in all fibers
of $\psi$.

In practice, the family intersection is perhaps the most ubiquitous type
constructor in Nuprl developments, as it facilitates the simultaneous
specification and implementation of programs in type theory, without causing
details of the program's verification to leak into the extracted algorithm.
Additionally, the family intersection can be used to implement coinductive
types.

\paragraph{Dependent intersection}
The dependent intersection $\Refines{\Upsilon}{(x:\phi)\cap\psi}{\sigma}$
contains the members $M$ of $\phi$ which are also members of
$\Subst{M}{x}{\psi}$:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{
      (x:\phi)\cap\psi
    }
  }{
    \RMemEq{\Upsilon'}{M}{N}{\phi} &
    \RMemEq{\Upsilon'}{M}{N}{
      \Subst{M}{x}{\psi}
    }
  }
\]

The dependent intersection, first introduced by Kopylov in \cite{kopylov:2000},
is a generalization of the binary intersection to the dependent case, not to
be confused with the intersection of a family of sets. The dependent
intersection has many applications, including the compositional representation
of \emph{dependent records} or modules in Type Theory.

\paragraph{Family union}
The union $\Refines{\Upsilon}{\bigcup_{(x:\phi)}\psi}{\tau}$ of a family of
refinements is defined by the following rule:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{
      \bigcup_{(x:\phi)}\psi
    }
  }{
    \RMemEq{\Upsilon'}{L_0}{L_1}{\phi} &
    \RMemEq{\Upsilon'}{M}{N}{
      \Subst{L_0}{x}{\psi}
    }
  }
\]

The union of a family of refinements can be used to implement inductive types,
among other things.

\paragraph{Set comprehension}

We can also use a family of refinements to define something analogous to set
comprehension, $\Refines{\Upsilon'}{\MkSet{x:\phi\mid\psi}}{\sigma}$, defined
as follows:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{
      \MkSet{x:\phi\mid\psi}
    }
  }{
    \RMemEq{\Upsilon'}{M}{N}{\phi} &
    \RMemEq{\Upsilon'}{L_0}{L_1}{
      \Subst{M}{x}{\psi}
    }
  }
\]

The set comprehension $\MkSet{x:\phi\mid\psi}$ contains just those elements of
$\phi$ such that their fibers of $\psi$ are inhabited; this can be seen as an
``implicit'' version of existential quantification, and can be used to
simultaneously specify and implement program without the evidence for $\psi$
intruding into the extracted algorithm.

\section{Multi-Sorted Computational Type Theory}
\label{sec:ctt}

Martin-L\"of's type theory is a theory of \emph{value types}: to define a type,
you specify how to form its equal canonical inhabitants, or values. Then, the
inhabitants of the types are explained uniformly by extending this relation
over an operational semantics such that two terms are equal members of a
type just when they compute to equal values of that type.

More generally, one may wish to consider types which include computations in
addition to values; an example of such a type would be $\psi_\bot$ when $\psi$
is a type, which would include all the members of $\psi$ as well as a divergent
computation. Another example is the type $\TyTop{\tau}$ which identifies all
closed terms of sort $\tau$.

In order to ensure that such types are sensible, we must formulate a notion of
computational equivalence, and then say that a refinement is a \emph{type} just
when it respects computational equivalence; then, we are able to define types
as PERs on \emph{programs} in addition to values.


\subsection{Lazy Computation Systems}

In this section we generalize Howe's notion of lazy computation
system~\cite{howe:1989} to the multi-sorted, symbol-parameterized setting. An
\emph{lazy computation language} is an abt signature
$\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$ along with a distinguished
arity-indexed family of copresheaves
$\HypJ{\Of{\CanOperators_a}{\Sets^\SCtx}}{\Member{a}{\Arities}}$ of
\emph{canonical} operators such that
$\IsSubsetEq{\CanOperators_a}{\Operators_a}$ for each arity $a$.

For a lazy computation language
$\Match{L}{\Tuple{\Sorts,\Operators,\CanOperators}}$, let us define
sort-indexed (resp.\ valence-indexed) copresheaves on $\SCtx$ of closed values
(resp.\ bound terms) as follows:
\begin{align*}
  \ADefine{\Values_\tau(\Upsilon)}{
    \MkSet{
      M\equiv\App{\vartheta}{\vec{E}}
      \mid M\in\Exprs_\tau(\Upsilon)\land \exists a. \CanOperators_a(\Upsilon)\ni\vartheta
    }
  }\\
  \ADefine{
    \BTms_{v}(\Upsilon)
  }{
    \MkSet{E \mid \IsAbtUnmoded{\cdot}{\Upsilon}{\cdot}{E}{v}}
  }
\end{align*}

Then, a \emph{lazy computation system} (lcs) is a lazy computation language
$\Match{L}{\Pair{\Sigma}{\CanOperators}}$ along with a partial, $\SCtx$-indexed
$\equiv_\alpha$-functional evaluation relation
$\EvalN{\Upsilon}{\tau}{n}{M}{N}$ presupposing $\Member{n}{\Naturals}$,
$\Member{M}{\Exprs_\tau(\Upsilon)}$ and $\Member{N}{\Values_\tau(\Upsilon)}$,
expressing that $M$ evaluates to $N$ in $n$ steps.  We will write
$\Eval{\Upsilon}{\tau}{M}{N}$ to mean that there exists an $n$ such that
$\EvalN{\Upsilon}{\tau}{n}{M}{N}$.

\newcommand\PBinRel[4]{\IMode{#2}\parallel\IMode{#3}\mathrel{#1}\IMode{#4}}
\newcommand\HPBinRel[5]{\IMode{#2}\parallel\IMode{#3}\vDash\IMode{#4}\mathrel{#1}\IMode{#5}}

\begin{notation*}
  For a family of copresheaves $\HypJ{\Of{X_i}{\SemU}}{\Member{i}{I}}$, we will
  use $X^{[\vec{i}]}$ as a shorthand for the following iterated product, as
  in \cite{sterling-morrison:2015}:

  \[
    \Define{
      X^{[\vec{i}]}
    }{
      \prod_{i\in\vec{i}}
        X_i
    }
  \]
\end{notation*}

Fix a sort-indexed family of binary relations on closed expressions
$\Of{R_\tau}{\Hom{\SemU}{\mathbb{1}}{\Pow{\Exprs_\tau^2}}}$; we will
also write the relation as a judgment scheme
$\PBinRel{R_\tau}{\Upsilon}{M}{N}$. First of all, we can lift such a relation
to operate on open terms by quantifying over substitutions, as follows:
\[
  \infer{
    \HPBinRel{R_\tau}{\Upsilon}{\vec{x}:\vec{\sigma}}{M}{N}
  }{
    \forall
      \begin{tikzcd}[cramped, ampersand replacement = \&]
         \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
      \end{tikzcd}.
    \quad
    \forall \Of{\vec{X}}{\Exprs^{[\vec{\sigma}]}(\Upsilon')}.
    \quad
    \PBinRel{R_\tau}{\Upsilon'}{
      \Subst{\vec{X}}{\vec{x}}{\Rename{\rho}{M}}
    }{
      \Subst{\vec{X}}{\vec{x}}{\Rename{\rho}{M}}
    }
  }
\]

Next, we can always extend $R_\tau$ to a new
family of valenced-indexed relations
$\Of{R_v}{\Hom{\SemU}{\mathbb{1}}{\Pow{\BTms_v^2}}}$ for
$\Match{v}{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}$, defined pointwise as
follows:
\[
  \infer{
    \PBinRel{R_{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}}{\Upsilon}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{v}}{\vec{y}}{N}
    }
  }{
    \begin{array}{l}
      \forall\IMode{\vec{w}}\mathrel{\#}\IMode{\Dom{\Upsilon}\cup\vec{u}\cup\vec{v}}.\quad
      \forall\IMode{\vec{z}}\mathrel{\#}\IMode{\vec{x}\cup\vec{y}}.\\
      \HPBinRel{R_\tau}{\Upsilon,\vec{w}:\vec{\sigma}}{\vec{z}:\vec{\tau}}{
        \Subst{\vec{z}}{\vec{x}}{
          \Rename{(\vec{u}\mapsto\vec{w})}{M}
        }
      }{
        \Subst{\vec{z}}{\vec{y}}{
          \Rename{(\vec{v}\mapsto\vec{w})}{M}
        }
      }
    \end{array}
  }
\]


As a matter of convenience, we'll also define this judgment over vectors of
bound terms and valences:
\[
  \infer{
    \PBinRel{R_{\vec{v}}}{\Upsilon}{\vec{E}}{\vec{F}}
  }{
    \forall\Member{(E,F,v)}{(\vec{E},\vec{F},\vec{v})}.\
    \PBinRel{R_v}{\Upsilon}{E}{F}
  }
\]

Now, we can extend $R_\tau$ to a new relation $[R_\tau]$ on closed expressions
which respects a single ``layer'' of computation. We will say
$\PBinRel{[R_\tau]}{\Upsilon}{M}{N}$ when, supposing
$\Eval{\Upsilon}{\tau}{M}{\App{\vartheta}{\Vec{E}}}$ such that
$\IsCanOperator{\Upsilon}{\vartheta}{\MkArity{\vec{v}}{\tau}}$,
for any
\begin{tikzcd}[cramped]
  \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
\end{tikzcd}
, we have $\Eval{\Upsilon'}{\tau}{\Rename{\rho}{N}}{\App{\Rename{\rho}{\vartheta}}{\Rename{\rho}{\Vec{F}}}}$ and
$\PBinRel{R_{\vec{v}}}{\Upsilon'}{\Rename{\rho}{\vec{E}}}{\Rename{\rho}{\vec{F}}}$.

\begin{definition}[Computational Approximation]
  Because $[-_\tau]$ is monotonic, it has a greatest fixed point, which we will
  call \emph{computational approximation},
  $\Of{\preccurlyeq_\tau}{\Hom{\SemU}{\mathbb{1}}{\Pow{\Exprs_\tau^2}}}$,
  written pointwise as $\PBinRel{\preccurlyeq_\tau}{\Upsilon}{M}{N}$.
\end{definition}

\begin{thm}[Reflexivity]\label{thm:approx-refl}
  For all $\Member{M}{\Exprs_\tau(\Upsilon)}$, we have $\PBinRel{\preccurlyeq_\tau}{\Upsilon}{M}{M}$.
\end{thm}
\begin{proof}
  The proof proceeds by coinduction, using the relation
  $\IMode{M,N}\mapsto\OMode{M = N}$ as our motive; then, it suffices to show
  that for all $M$, $\PBinRel{[=]}{\Upsilon}{M}{M}$. Expanding the definition
  of $[-]$, this means that we have to show that when
  $\Eval{\Upsilon}{\tau}{M}{\App{\vartheta}{\vec{E}}}$, then
  $\IsEq{\vec{E}}{\vec{E}}$; but this is always the case, because of the
  functionality/determinacy of the evaluation relation.
\end{proof}

\begin{definition}[Computational Equivalence]
  Two terms are said to be \emph{computationally equivalent} when they approximate each other:
  \[
    \infer{
      \PBinRel{\sim_\tau}{\Upsilon}{M}{N}
    }{
      \PBinRel{\preccurlyeq_\tau}{\Upsilon}{M}{N} &
      \PBinRel{\preccurlyeq_\tau}{\Upsilon}{N}{M}
    }
  \]
\end{definition}

\subsection{Extensionality and Observational Congruence}

A sort-indexed family of binary relations
$\HypJ{\Of{R_\tau}{\Hom{\SemU}{\mathbb{1}}{\Pow{\Exprs_\tau^2}}}}{\Member{\tau}{\Sorts}}$
is a \emph{congruence} when for all operators
$\IsOperator{\Upsilon}{\vartheta}{\MkArity{\vec{v}}{\tau}}$, the following rule
obtains:
\[
  \infer{
    \PBinRel{R_\tau}{\Upsilon}{\vartheta(\vec{E})}{\vartheta(\vec{F})}
  }{
    \PBinRel{R_{\vec{v}}}{\Upsilon}{\vec{E}}{\vec{F}}
  }
  \tag{Congruence}
\]

In general, computational equivalence is not a congruence unless we impose a
certain extensionality condition on operators. First, let us define a new
version of approximation $\preccurlyeq^\star_\tau$ over open terms:
\begin{gather*}
  \infer[\textit{var}]{
    \HPBinRel{\preccurlyeq^\star_\tau}{\Upsilon}{\Gamma}{x}{y}
  }{
    \HPBinRel{\preccurlyeq_\tau}{\Upsilon}{\Gamma}{x}{y}
  }
  \qquad
  \infer[\textit{app}]{
    \HPBinRel{\preccurlyeq^\star_\tau}{\Upsilon}{\Gamma}{
      \App{\vartheta}{\vec{E}}
    }{
      N
    }
  }{
    \IsOperator{\Upsilon}{\vartheta}{\MkArity{\vec{v}}{\tau}} &
    \exists\IMode{\vec{F}}. &
    \HPBinRel{\preccurlyeq^\star_{\vec{v}}}{\Upsilon}{\Gamma}{
      \vec{E}
    }{
      \vec{F}
    } &
    \HPBinRel{\preccurlyeq_\tau}{\Upsilon}{\Gamma}{
      \App{\vartheta}{\vec{F}}
    }{
      N
    }
  }
\end{gather*}

We will write $\PBinRel{\preccurlyeq^\star_\tau}{\Upsilon}{M}{N}$ for
$\HPBinRel{\preccurlyeq^\star_\tau}{\Upsilon}{\cdot}{M}{N}$.  By definition,
$\preccurlyeq^\star_\tau$ is a congruence; to show that $\sim_\tau$ is a
congruence, it suffices to show that the following inference is valid:
\[
  \infer[?]{
    \HPBinRel{\preccurlyeq_\tau}{\Upsilon}{\Gamma}{M}{N}
  }{
    \HPBinRel{\preccurlyeq^\star_\tau}{\Upsilon}{\Gamma}{M}{N}
  }
\]

We will not reproduce the full proof of the above rule here (see
\cite{howe:1989}), but will simply remark that it holds only for what is called
an \emph{extensional lcs}, an lcs in which each operator is extensional in the
following sense:

\begin{definition}[Extensionality]
  \label{def:extensionality}

  An operator $\IsOperator{\Upsilon}{\vartheta}{\MkArity{\vec{v}}{\tau}}$ is
  \emph{extensional} when, for any
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}%
  , for all $\Member{\vec{E},\vec{F}}{\BTms^{[\vec{v}]}(\Upsilon')}$ and
  $\Member{M}{\Exprs_\tau(\Upsilon')}$ and $\IMode{k}\geq\IMode{0}$, if we can conclude
  $\PBinRel{\preccurlyeq^\star_\tau}{\Upsilon'}{M}{\App{\Rename{\rho}{\vartheta}}{\vec{F}}}$
  from the following conditions:
  %
  \begin{enumerate}
    \item
      We have $\EvalN{\Upsilon'}{\tau}{k}{\App{\Rename{\rho}{\vartheta}}{\vec{E}}}{M}$.

    \item
      We have $\PBinRel{\preccurlyeq^\star_{\vec{v}}}{\Upsilon'}{\vec{E}}{\vec{F}}$.

    \item
      For any
      \begin{tikzcd}[cramped]
        \IMode{\Upsilon'} \arrow[r,hook,"\IMode{\rho'}"] &\IMode{\Upsilon''}
      \end{tikzcd}%
      , for all $\Member{\sigma}{\Sorts}$ and $\Member{X,X',Y}{\Exprs_\sigma(\Upsilon'')}$, if
      from $\EvalN{\Upsilon''}{\sigma}{k'}{X}{X'}$ for $\IMode{k'}<\IMode{k}$ and
      $\PBinRel{\preccurlyeq^\star_\sigma}{\Upsilon''}{X}{Y}$, we can conclude
      $\PBinRel{\preccurlyeq^\star_\sigma}{\Upsilon''}{X'}{Y}$.
  \end{enumerate}

\end{definition}

\begin{thm}
  Every canonical operator
  $\IsCanOperator{\Upsilon}{\vartheta}{\MkArity{\vec{v}}{\tau}}$ is
  extensional.
\end{thm}

\begin{proof}
  Fix
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}%
  and $\Member{\vec{E},\vec{F}}{\BTms^{[\vec{v}]}(\Upsilon')}$ and
  $\Member{M}{\Exprs_\tau(\Upsilon')}$ and $\IMode{k}\geq\IMode{0}$.
  %
  By hypothesis (1) from Definition~\ref{def:extensionality} above, we have
  $\EvalN{\Upsilon'}{\tau}{k}{\App{\Rename{\rho}{\vartheta}}{\vec{E}}}{M}$;
  because $M$ is a closed term, by the idempotency of evaluation we have
  $\Match{M}{\App{\Rename{\rho}{\vartheta}}{\vec{E}}}$.

  It suffices, then, to show that
  $\PBinRel{\preccurlyeq^\star_\tau}{\Upsilon'}{\App{\Rename{\rho}{\vartheta}}{\vec{E}}}{\App{\Rename{\rho}{\vartheta}}{\vec{F}}}$.
  %
  Backward chaining through the \textit{app}-rule of $\preccurlyeq^\star$, we must
  come up with a certain $\vec{G}$ such that the following subgoals obtain:
  \begin{enumerate}
    \item $\PBinRel{\preccurlyeq^\star_{\vec{v}}}{\Upsilon'}{\vec{E}}{\vec{G}}$
    \item $\PBinRel{\preccurlyeq_\tau}{\Upsilon'}{\App{\Rename{\rho}{\vartheta}}{\vec{G}}}{\App{\Rename{\rho}{\vartheta}}{\vec{F}}}$
  \end{enumerate}

  Setting $\Define{\vec{G}}{\vec{F}}$, we discharge the first subgoal through
  hypothesis (2); the second hypothesis holds because of the reflexivity of
  approximation (Theorem~\ref{thm:approx-refl}).

\end{proof}

\subsection{When is a refinement a type?}

As we remarked in section~\ref{sec:parametric-refinement}, the notion of
\emph{refinement} that we described is very much akin to a multi-sorted
generalization of Martin-L\"of's explanation of types
in~\cite{martin-lof:1979}, except that we have not required an operational
semantics to be present prior to the definition of refinements.

Following Martin-L\"of, a type is a refinement which behaves well with respect
to computation, in some specified sense; contrary to Martin-L\"of, however, we wish to
consider a full range of \emph{computational types}, including those which are
not necessarily defined by their values; a general apparatus for
computation-respecting refinements will allow us to define, for instance, a
type for partial functions.

\begin{definition}[Typehood]
  For any refinement $\Refines{\Upsilon}{\phi}{\tau}$, we say
  $\IsType{\Upsilon}{\phi}{\tau}$ just when for any
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}%
  , and for all $\Member{L,M,N}{\Exprs_\tau(\Upsilon')}$, from
  $\PBinRel{\sim_\tau}{\Upsilon'}{L}{M}$ and $\RMemEq{\Upsilon'}{M}{N}{\phi}$ we
  can conclude $\RMemEq{\Upsilon'}{L}{N}{\phi}$.
\end{definition}

Stated internally as an object in $\SemU$, the meaning of parametric typehood for
$\phi$ is perhaps a bit more clear:
\[
  \Define{
    \IsType{-}{\phi}{\tau}
  }{
    \prod_{L,M,N\in\Exprs_\tau}
    {\phi(L,N)}^{L\sim_\tau M \times \phi(M,N)}
  }
\]

Let us write $\Types{\tau}$ for the object of types,
\[
  \Define{
    \Types{\tau}
  }{
    \MkSet{
      \phi\in\PERs{\Exprs_\tau}
      \mid
      -\parallel\phi\ \textit{type}_\tau
    }
  }
\]

Now, let us return briefly to Martin-L\"of's notion of type, which we call a
\emph{value type}. The minimal data of such a type's definition consists in a
partial equivalence relation on values,
$\Of{\phi}{\Hom{\SemU}{\Coyoneda{\Upsilon}}{\PERs{\Values_\tau}}}$.  It
is easy to turn such a relation into a computational type
$\IsType{\Upsilon}{\VToCType(\phi)}{\tau}$, as follows, where $\lambda(\chi)$
is the exponential transpose of $\chi$:
\[
  \begin{tikzcd}[sep=huge]
    \IMode{\Coyoneda{\Upsilon}\times\Values_\tau^2}
      \arrow[r, "\IMode{\lambda(\phi)}"]
      \arrow[d, hook, swap, "\IMode{\Pair{\ArrId{}}{i}}"]
      &
    \IMode{\Omega}\\
    \IMode{\Coyoneda{\Upsilon}\times\Exprs_\tau^2}
    \arrow[ur, swap, dotted, "\OMode{\lambda(\VToCType(\phi))}"]
  \end{tikzcd}
\]
where $\VToCType(\phi)$ is the computational extension of $\phi$ in the following sense:
\begin{align*}
  \ADefine{
    \VToCType(\phi)(M,N)
  }{
    \forall M', N' \in \Values_\tau.\
    M\sim_\tau M' \land N\sim_\tau N' \implies \phi(M',N')
  }
\end{align*}

\begin{thm}
When viewed as an internal functor
$\PERs{\Values_\tau}\to\Types{\tau}$, $\VToCType$ is the left adjoint to
the canonical inclusion
$\Of{\iota}{\Types{\tau}\inj\PERs{\Values_\tau}}$.
\end{thm}
\begin{proof}
  We will exhibit a counit $\Of{\epsilon}{\VToCType\circ\iota\to
  \ArrId{\PERs{\Values_\tau}}}$ and a unit
  $\Of{\eta}{\ArrId{\Types{\tau}}\to\iota\circ\VToCType}$ for
  the adjunction $\IMode{\VToCType}\dashv\IMode{\iota}$.

  The counit witnesses the fact that for any refinement
  $\Of{\phi}{\Types{\tau}}$ and terms $\Member{M,N}{\Exprs_\tau}$, if
  $\VToCType(\iota(\phi))(M,N)$, then $\phi(M,N)$; this is evidently the case,
  because the premise only obtains if $M,N$ are computationally equal to
  values, and $\phi$ respects computational equivalence by virtue of being a
  type.  The unit witnesses the fact that for any value PER
  $\Of{\psi}{\PERs{\Values_\tau}}$ and values $\Member{M,N}{\Values_\tau}$, if
  $\psi(M,N)$, then $\iota(\VToCType(\psi))(M,N)$; this is clearly true, since
  $\VToCType(\psi)$ can do nothing but coarsen $\psi$'s relation on values.

\end{proof}

\begin{definition}[Value Closure]
  For any computational type $\IsType{\Upsilon}{\phi}{\tau}$, let
  $\Define{\underline{\phi}}{\VToCType(\iota(\phi))}$ be called $\phi$'s
  \emph{value closure}, which we will use shortly in order to give a formal
  definition to the notion of value types.
\end{definition}

\begin{definition}[Value Types]
  We can give a simple characterization of Martin-L\"of's \emph{value types} in
  terms of our more general computational types. For any type
  $\IsType{\Upsilon}{\phi}{\tau}$, we will say
  $\IsValueType{\Upsilon}{\phi}{\tau}$ in case $\phi$ is equal to its value
  closure, i.e.\ $\EqRefines{\Upsilon}{\phi}{\underline{\phi}}{\tau}$.
\end{definition}

\paragraph{Functional Typehood}
\newcommand\PTyFamNil{\vDash^\textit{type}_{\mathtt{nil}}}
\newcommand\PTyFamSnoc{\vDash^\textit{type}_{\mathtt{snoc}}}

Let us define functional typehood
$\EqTypeFam{\Upsilon}{\Psi}{\phi}{\psi}{\tau}$, presupposing
$\FEqRefines{\Upsilon}{\Psi}{\phi}{\psi}{\tau}$. As usual, we
give our meaning explanation by induction on the evidence for
the validity of the refined context $\Psi$.

\paragraph{Case} $\DefRefinesCtxNil{\Upsilon}$.
\[
  \infer[\PTyFamNil]{
    \EqTypeFam{\Upsilon}{\cdot}{\phi}{\psi}{\tau}
  }{
    \IsType{\Upsilon}{\phi}{\tau}
  }
\]
Note that this case is not trivial, because it is only defined in
case the presupposition $\FEqRefines{\Upsilon}{\Psi}{\phi}{\psi}{\tau}$
obtains. It suffices to require only that $\phi$ be a type, since because
typehood respects equality of refinement.

\paragraph{Case} $\DefRefinesCtxSnoc{\Upsilon}{\Psi}{x}{\chi}{\Gamma}{\sigma}$.

\begin{quote}
  To know $\EqTypeFam{\Upsilon}{\Psi,x:\chi}{\phi}{\psi}{\tau}$ is to know,
  for any renaming
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}
  and closed terms $\Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}$, that from
  $\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}$, you can conclude
  $\EqTypeFam{\Upsilon'}{\Rename{\rho}{\Psi}}{\Subst{M_0}{x}{\Rename{\rho}{\phi}}}{\Subst{M_1}{x}{\Rename{\rho}{\psi}}}{\tau}$.
  In other words:
  %
  \[
    \infer[\PTyFamSnoc]{
      \EqTypeFam{\Upsilon}{\Psi,x:\chi}{\phi}{\psi}{\tau}
    }{
      \begin{array}{l}
        \forall
        \begin{tikzcd}[cramped, ampersand replacement = \&]
          \IMode{\Upsilon} \arrow[r,hook,"\IMode{\rho}"] \&\IMode{\Upsilon'}
        \end{tikzcd}
        .\ \forall \Member{M_0,M_1}{\Exprs_\sigma(\Upsilon')}.\\
        \left(\FRMemEq{\Upsilon'}{\Rename{\rho}{\Psi}}{M_0}{M_1}{\Rename{\rho}{\chi}}\right)\\
        \quad\implies
        \left(\EqTypeFam{\Upsilon'}{\Rename{\rho}{\Psi}}{\Subst{M_0}{x}{\Rename{\rho}{\phi}}}{\Subst{M_1}{x}{\Rename{\rho}{\psi}}}{\tau}\right)
      \end{array}
    }
  \]
\end{quote}

As with refinements, we will write $\IsTypeFam{\Upsilon}{\Psi}{\phi}{\tau}$
to mean $\EqTypeFam{\Upsilon}{\Psi}{\phi}{\phi}{\tau}$.

\subsection{Examples of refinements and their typehood}

We will demonstrate how to define certain refinements, and prove that they are
types. The refinements below will differ from the ones defined in Section~

\subsubsection{The type of closed expressions}

The \emph{discrete} refinement on a sort (which equates each closed term only
with itself, up to alpha equivalence) is not a type in general, because it may
not respect computational equivalence. However, we can form the next best
thing, which is called the \emph{base} refinement, which identifies closed
expressions of a sort up to computational equivalence.

Let $\GloballyRefines{\TyBase{\tau}}{\tau}$ for any sort $\tau$ be defined as
follows:
\[
  \infer{
    \RMemEq{\Upsilon}{M}{N}{\TyBase{\tau}}
  }{
    \PBinRel{\sim_\tau}{\Upsilon}{M}{N}
  }
\]

Then, we clearly have $\IsType{\Upsilon}{\TyBase{\tau}}{\tau}$, because it respects
computational equivalence by definition.

\subsubsection{The type of atoms}
\newcommand\SortAtom{\mathtt{atom}}
\newcommand\OpToken[1]{\mathtt{tok}[#1]}
\newcommand\OpMatch[1]{\mathtt{match}_{#1}}
\newcommand\Atoms{\mathbb{A}}

Fix an extensional lcs whose signature contains the following:
\[
  \infer{
    \IsSort{\SortAtom}
  }{
  }
  \qquad
  \infer{
    \IsCanOperator{\Upsilon,a:\SortAtom}{
      \OpToken{a}
    }{
      \MkArity{}{\SortAtom}
    }
  }{
  }
\]

Then, we can define a refinement $\GloballyRefines{\Atoms_0}{\SortAtom}$ as
follows:
\[
  \infer{
    \RMemEq{\Upsilon}{
      \App{\OpToken{a}}{}
    }{
      \App{\OpToken{a}}{}
    }{\Atoms_0}
  }{
    \IMode{\Upsilon}\ni\IMode{a}:\IMode{\SortAtom}
  }
\]

However, it is not the case that $\Atoms_0$ is a type, because it doesn't
respect computational equivalence. This is easily resolved by defining the type
of atoms as the computational extension of $\Atoms_0$,
\[
  \Define{
    \Atoms
  }{
    \VToCType(\Atoms_0)
  }
\]

\begin{thm}
  For any $\Upsilon$, we have $\IsType{\Upsilon}{\Atoms}{\SortAtom}$.
\end{thm}
\begin{proof}
  Trivial, because the computational extension of any value PER is a type.
\end{proof}

\subsubsection{Dependent function types}
\newcommand\SortArr[2]{#1\rightharpoonup #2}
\newcommand\OpLambda[2]{\mathtt{lam}_{#1}^{#2}}
\newcommand\OpAp[2]{\mathtt{ap}_{#1}^{#2}}

Fix an extensional lcs such that its signature contains the following:
\[
  \infer{
    \IsSort{\SortArr{\sigma}{\tau}}
  }{
    \IsSort{\sigma} &
    \IsSort{\tau}
  }
  \qquad
  \infer{
    \IsOperator{\Upsilon}{
      \OpAp{\sigma}{\tau}
    }{
      \MkArity{
        \MkValence{}{}{\SortArr{\sigma}{\tau}};
        \MkValence{}{}{\sigma}
      }{\tau}
    }
  }{
    \IsSort{\sigma} &
    \IsSort{\tau}
  }
\]

The sort $\SortArr{\sigma}{\tau}$ is intended to classify the (syntax of)
partial operations, and $\OpAp{\sigma}{\tau}$ is the application operator. Now,
we can define a refinement on this sort for dependent functions, and then prove
that it is a type. We intend to define a refinement $\prod_{(x:\phi)}\psi$
such that the following rule holds:
\[
  \infer{
    \Refines{\Upsilon}{\prod_{(x:\phi)}\psi}{\SortArr{\sigma}{\tau}}
  }{
    \Refines{\Upsilon}{\phi}{\sigma} &
    \FRefines{\Upsilon}{x:\phi}{\psi}{\tau}
  }
\]

For any renaming
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}%
, the meaning of $\prod_{(x:\phi)}\psi$ at
$\Member{M, N}{\Exprs_{\SortArr{\sigma}{\tau}}(\Upsilon')}$ is given by
the following rule:
\[
  \infer={
    \RMemEq{\Upsilon'}{M}{N}{
      \prod_{(x:\phi)}\psi
    }
  }{
    \FRMemEq{\Upsilon'}{x:\phi}{
      \App{\OpAp{\sigma}{\tau}}{M; x}
    }{
      \App{\OpAp{\sigma}{\tau}}{N; x}
    }{
      \psi
    }
  }
\]

Note that we have not required an introduction form such as
$\OpLambda{\sigma}{\tau}$, and have instead opted for a negative
definition of the dependent function refinement. This is strictly more
open-ended than the positive definition, because it does not fix in
advance a syntax for the canonical formation of functions.

\begin{thm}
  The dependent function refinement
  $\Refines{\Upsilon}{\prod_{(x:\phi)}\psi}{\SortArr{\sigma}{\tau}}$ is a
  type assuming $\IsType{\Upsilon}{\phi}{\sigma}$ and
  $\IsTypeFam{\Upsilon}{x:\phi}{\psi}{\tau}$.
\end{thm}
\begin{proof}
  Fix
    \begin{tikzcd}[cramped]
      \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
    \end{tikzcd}%
  , and $\Member{L,M,N}{\Exprs_{\SortArr{\sigma}{\tau}}(\Upsilon')}$ such that
  \begin{enumerate}
    \item $\PBinRel{\sim_{\SortArr{\sigma}{\tau}}}{\Upsilon'}{L}{M}$
    \item $\FRMemEq{\Upsilon'}{x:\Rename{\rho}{\phi}}{\App{\OpAp{\sigma}{\tau}}{M;x}}{\App{\OpAp{\sigma}{\tau}}{N;x}}{\Rename{\rho}{\psi}}$
  \end{enumerate}
%
  It suffices to show that
  $\FRMemEq{\Upsilon'}{x:\Rename{\rho}{\phi}}{\App{\OpAp{\sigma}{\tau}}{L;x}}{\App{\OpAp{\sigma}{\tau}}{N;x}}{\Rename{\rho}{\psi}}$.
%
  Now fix
    \begin{tikzcd}[cramped]
      \IMode{\Upsilon'}\arrow[r,hook,"\IMode{\rho'}"] &\IMode{\Upsilon''}
    \end{tikzcd}%
  , and $\Member{X,Y}{\Exprs_\sigma(\Upsilon'')}$ such that
  $\RMemEq{\Upsilon''}{X}{Y}{\Rename{(\rho'\circ\rho)}{\phi}}$.
  Then, we have to show that
  $\RMemEq{\Upsilon''}{%
    \App{\OpAp{\sigma}{\tau}}{
      \Rename{\rho'}{L};
      X
    }
  }{
    \App{\OpAp{\sigma}{\tau}}{
      \Rename{\rho'}{N};
      Y
    }
  }{\Subst{X}{x}{\Rename{(\rho'\circ\rho)}{\psi}}}$.

  Because $\psi$ is a functional family of types,
  $\Subst{X}{x}{\Rename{(\rho'\circ\rho)}{\psi}}$ must respect
  computational equivalence, so by drawing hypothesis (1) along $\rho'$, we
  can rewrite hypothesis (2) into the goal.
\end{proof}

\section{Related Work}

In \cite{allen:2006}, Stuart Allen gave a \emph{supervaluation} semantics for
Nuprl sequents involving atoms (symbols) by quantifying over plenty of choices
for the interpretation of atoms---possible interpretations including strings,
finite sets, etc. One benefit of Allen's indirect treatment is that the logical
theory remains profoundly open-ended, in the sense that it is neither the case
that the naturals may be injected into the atoms, nor is it the case that they
cannot.

\newcommand\AtomModel{\mathfrak{A}}
\newcommand\NuprlSeq[2]{\IMode{#1}\gg\IMode{#2}}
\newcommand\NuprlInterp[2]{\IMode{#1}\models\IMode{#2}}
\newcommand\NuprlInterpSeq[3]{\IMode{#1}\models\NuprlSeq{#2}{#3}}
\newcommand\Strings{\mathbf{String}}

Unlike in our treatment, where the judgments of type theory are intensional
with respect to symbol contexts, Allen takes a more model-theoretic approach
and parameterizes the explanation of type theory over a model $\AtomModel$ for
the abstract atoms.

A Nuprl sequent $\Define{\mathfrak{s}}{H\gg P}$ means ``$P$ is true under
hypotheses $H$'', and it may contain (abstract) atoms in its syntax; we write
$\FS{\mathfrak{s}}$ for the set of free atoms of the sequent $\mathfrak{s}$.
Then, a model $\AtomModel$ consists in a carrier set $\Dom{\AtomModel}$ which
shall interpret the atoms, and a valuation
$\NuprlInterp{\AtomModel}{\mathfrak{s}}$ for any Nuprl sequent $\mathfrak{s}$
which takes its atoms from $\Dom{\AtomModel}$.  A model is called
\emph{discrete} in case its carrier set has decidable equality.  For a Nuprl
sequent $\mathfrak{s}$ with atoms in $\AtomModel$ and an injective function
$\Of{\rho}{\Dom{\AtomModel}\inj\Dom{\AtomModel'}}$, let
$\Rename{\rho}{\mathfrak{s}}$ be the sequent with atoms in $\Dom{\AtomModel'}$
got by replacing each atom $a$ with $\rho(a)$.

Then, a supervaluation is given for Nuprl sequents which take atoms in
$\Strings$, written $\NuprlInterp{*}{\mathfrak{s}}$, which holds if there
exists a $\Member{k}{\Naturals}$ such that for every discrete model
$\AtomModel$ having at least $k$ members, for every injection
$\Of{\rho}{\FS{\mathfrak{s}} \inj \AtomModel}$, we have
$\NuprlInterp{\AtomModel}{\Rename{\rho}{\mathfrak{s}}}$. Under the
supervaluation, we can rule out certain observations about atoms which might
hold in particular models.

For instance, assuming a type $\Naturals$ of natural numbers and $\Atoms$
of atoms, with $\Naturals\inj\Atoms$ the type of embeddings of the naturals
into the atoms, we do have
$\NuprlInterpSeq{\Strings}{\cdot}{\Naturals\inj\Atoms}$, because there are
numerous ways to embed the naturals into the strings; however, because the
embedding fails in every finite model $\AtomModel$, we do not have
$\NuprlInterpSeq{*}{\cdot}{\Naturals\inj\Atoms}$.  Furthermore, we also do
not have $\NuprlInterpSeq{*}{\iota:\Naturals\inj\Atoms}{\bot}$, because this
would fail in any infinite model.

\paragraph{Comparison with the present work}

Our explanation of atoms is not equivalent to the supervaluation semantics.
First, let us introduce a notion analogous to the Nuprl sequent: when
$\RefinesCtx{\cdot}{\Phi}{\Gamma}$ and $\FRefines{\cdot}{\Phi}{\phi}{\tau}$, we
can form the sequent $\NuprlSeq{\Phi}{\phi}$, meaning that there exists an
$\Member{\Upsilon}{\SCtx}$ and
$\Member{M}{\Exprs_\tau(\Upsilon\parallel\Gamma)}$ such that
$\FRMemEq{\Upsilon}{\Phi}{M}{M}{\phi}$. We will write
$\models\NuprlSeq{\Phi}{\phi}$ when $\NuprlSeq{\Phi}{\phi}$ obtains.

\begin{thm}
  \label{thm:no-nat-injection}
  As in the supervaluation semantics, we have
  $\not\models\NuprlSeq{\cdot}{\Naturals\inj\Atoms}$.
\end{thm}
\begin{proof}
  Suppose $\models\NuprlSeq{\cdot}{\Naturals\inj\Atoms}$. Then, there
  exists an $\Member{\Upsilon}{\SCtx}$ and $\Member{M}{\Exprs_\tau(\Upsilon)}$
  such that $\RMemEq{\Upsilon}{M}{M}{\Naturals\inj\Atoms}$; but this
  is impossible because it would require a means of embedding the naturals into
  finite $\Dom{\Upsilon}$.
\end{proof}

\begin{thm}
  \label{thm:never-nat-injection}
  Contrary to the supervaluation semantics, we do have
  $\models\NuprlSeq{\iota:\Naturals\inj\Atoms}{\bot}$.
\end{thm}
\begin{proof}
  It suffices to show that for all $\Upsilon$, there is no $\iota$ such that
  $\RMemEq{\Upsilon}{\iota}{\iota}{\Naturals\inj\Atoms}$. However, by the
  definition of $\SCtx$, all $\Member{\Upsilon}{\SCtx}$ are finite, so there
  can be no injection of the naturals into $\Dom{\Upsilon}$.
\end{proof}

Another seemingly paradoxical observation is possible:

\begin{thm}
  \label{thm:never-atom-injection}
  The atoms may not be embedded into the naturals, i.e.\
  $\models\NuprlSeq{\iota:\Atoms\inj\Naturals}{\bot}$.
\end{thm}
\begin{proof}

  Fix a symbol context $\Upsilon$; suppose we have an $\Member{\iota}{\Exprs(\Upsilon)}$ such that
  $\RMemEq{\Upsilon}{\iota}{\iota}{\Atoms\inj\Naturals}$. Then, by inversion we
  have
  $\FRMemEq{\Upsilon}{x:\Atoms}{\App{\OpAp{}{}}{\iota;x}}{\App{\OpAp{}{}}{\iota;x}}{\Naturals}$;
  in other words, for all
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r,hook,"\IMode{\rho}"] &\IMode{\Upsilon'}
  \end{tikzcd}
  and $\Member{a}{\Dom{\Upsilon}}$, we have
  $\RMemEq{\Upsilon'}{\App{\OpAp{}{}}{\iota;a}}{\App{\OpAp{}{}}{\iota;a}}{\Naturals}$
  such that $\iota$ is injective.
  But the only way for $\iota$ to assign a different index to each atom is for
  it to test each atom in $\Dom{\Upsilon'}$ separately---but $\iota$ may only
  mention the atoms in $\Dom{\Upsilon}$.
\end{proof}

\paragraph{Should the above be worrisome?}

At the very least, the fact that neither the naturals nor the atoms may be
embedded into the other commits us to a truly intuitionistic ontology, as
opposed to a merely constructive one. In particular, our framework is
anti-classical in at least a na\"ive sense, because the Axiom of Choice puts
each set in bijection with a cardinal, whence it is impossible for neither of
two sets to embed in the other. However, it is important to note that as far as
the propositions-as-types principle is concerned, Computational Type Theory is
already anti-classical, as the undecidability of the halting problem can be
observed internally.

In fact, we view the simultaneous validity of
Theorems~\ref{thm:never-nat-injection}~and~\ref{thm:never-atom-injection} as
totally desirable, because we adhere to a strictly Brouwerian conception of
data. The proper way to view the type of atoms is as an ongoing act of free
generation---and it is a basic fact concerning the activity of an idealized
mathematician that at each stage, only a finite number of constructions shall
have been effected so far.

On the other hand, (the analogues of) these theorems are \emph{not} valid under
Allen's supervaluation semantics, because one would have to account for worlds
at which an infinite number of atoms had already been generated; in this way,
the open-endedness of Allen's semantics relies crucially on a condition that is
simply impossible under a Brouwerian conception of mathematical activity.

\ifdraft{}{
  \newpage
  \nocite{maclane:1971}
  \bibliographystyle{abbrv}
  \bibliography{refs}
}


\end{document}
