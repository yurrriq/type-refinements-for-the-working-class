\documentclass[11pt]{article}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{leftidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{catchfilebetweentags}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifdraft}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{scalerel}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{tikzpfeile}
\usepackage{url}
\usepackage[titletoc,title]{appendix}
\usepackage{todonotes}

\newif\ifcolored%
\coloredtrue%

%% fonts
\usepackage{pxfonts}
\usepackage{eulervm}
\usepackage[
  activate={true,nocompatibility},
  kerning=true,
  spacing=true,
  tracking=true
]{microtype}
\usepackage{bbold}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\newtheorem*{remark*}{Remark}
\numberwithin{equation}{section}

\ifcolored%
  \def\IModeColorName{MidnightBlue}
  \def\OModeColorName{Maroon}
\else
  \def\IModeColorName{Black}
  \def\OModeColorName{Black}
\fi

\newcommand\IMode[1]{{\color{\IModeColorName}{#1}}}
\newcommand\OMode[1]{{\color{\OModeColorName}{#1}}}

\newcommand\HypJ[2]{#1\ \ \left(#2\right)}
\newcommand\GenJ[2]{\vert_{\IMode{#1}}\; #2}
\newcommand\HPGenJ[4]{\vert^{\IMode{#1}\parallel\IMode{#2}}_{\IMode{#3}}\; #4}

\newcommand\IsTac[1]{\IMode{#1}\ \textit{tactic}}

\newcommand\MkSet[1]{\left\{#1\right\}}
\newcommand\Member[2]{\IMode{#1}\in\IMode{#2}}
\newcommand\EqMember[3]{\IMode{#1}=\IMode{#2}\in\IMode{#3}}
\newcommand\Of[2]{\IMode{#1}: \IMode{#2}}

\newcommand\MkValence[3]{%
  \ifthenelse{\equal{#1}{}}{}{%
    \{#1\}%
  }%
  \ifthenelse{\equal{#2}{}}{}{%
    [#2]%
  }.\, #3%
}
\newcommand\MkBTm[3]{\mathbb{\lambda}\{#1\}[#2].\, #3}
\newcommand\MkArity[2]{(#1)\, #2}
\newcommand\IsArity[1]{\IMode{#1}\ \textit{arity}}
\newcommand\IsValence[1]{\IMode{#1}\ \textit{valence}}
\newcommand\IsSort[1]{\IMode{#1}\ \textit{sort}}
\newcommand\Leq[2]{\IMode{#1}\leq\IMode{#2}}

\newcommand\ArrId[1]{1_{#1}}
\newcommand\Match[2]{\IMode{#1}\equiv\OMode{#2}}
\newcommand\MapsTo[2]{\IMode{#1}\mapsto\OMode{#2}}

\newcommand\Symbols{\mathbf{I}}
\newcommand\SymSets{\mathbb{F}_\Symbols}
\newcommand\FinSets{\mathbb{F}}
\newcommand\Sorts{\mathcal{S}}
\newcommand\Valences{\mathcal{V}}
\newcommand\Arities{\mathcal{A}}
\newcommand\Operators{\mathcal{O}}
\newcommand\CanOperators{\mathcal{K}}

\newcommand\Cats{\mathbf{Cat}}
\newcommand\Discrete[1]{#1_{\equiv}}
\newcommand\Arr[1]{\mathbf{{#1}^{\ra}}}
\newcommand\Sets{\mathbf{Set}}
\newcommand\SCtx{\mathbf{SCtx}}
\newcommand\Ctx{\mathbf{Ctx}}
\newcommand\Seq{\mathbf{Seq}}
\newcommand\HypCat{\mathbf{H}}

\newcommand\OpCat[1]{#1^{\mathsf{op}}}

\newcommand\IsOperator[3]{\IMode{#1}\Vdash\IMode{#2}: \OMode{#3}}

\newcommand\IsMetaCtx[1]{\IMode{#1}\ \textit{mctx}}
\newcommand\IsVarCtx[1]{\IMode{#1}\ \textit{vctx}}
\newcommand\IsSymCtx[1]{\IMode{#1}\ \textit{sctx}}

\newcommand\Lookup[3]{\IMode{#1}\ni\IMode{#2}:\OMode{#3}}

\newcommand\Grothendieck[2]{\oint^{#1} #2#1}
\newcommand\Pair[2]{\left\langle#1, #2 \right\rangle}
\newcommand\Tuple[1]{\left\langle#1 \right\rangle}
\newcommand\FLift[2]{
  \Operators\langle#1%
  \ifthenelse{\equal{#2}{}}{}{, #2}\rangle%
}
\newcommand\PairTimes[2]{\langle#1\, {\scriptstyle{{\times}}}\, #2 \rangle}
\newcommand\SSingleton{\bullet}
\newcommand\Forget[1]{|\, #1\, |}

\newcommand\Comma[2]{#1 \downarrow#2}
\newcommand\Coslice[2]{#1\, /\, #2}

\newcommand\IsAbtUnmoded[5]{
  #1\triangleright%
  #2\parallel%
  #3\vdash%
  #4:\OMode{#5}%
}
\newcommand\IsAbt[5]{\IsAbtUnmoded{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}{\IMode{#4}}{\OMode{#5}}}
\newcommand\IsBTm[5]{\IsAbtUnmoded{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}{\IMode{#4}}{\IMode{#5}}}

\newcommand\MV[1]{\mathfrak{#1}}
\newcommand\MApp[3]{%
  #1
  \ifthenelse{\equal{#2}{}}{}{%
    \{#2\}%
  }%
  \ifthenelse{\equal{#3}{}}{}{%
    [#3]%
  }
}
\newcommand\App[2]{#1(#2)}
\newcommand\Dom[1]{\left\vert#1\right\vert}
\newcommand\FV[1]{\mathbf{FV}\left(#1\right)}
\newcommand\FS[1]{\mathbf{FS}\left(#1\right)}
\newcommand\NotIn[2]{\IMode{#1}\notin\IMode{#2}}
\newcommand\SortExp{\mathsf{exp}}

\newcommand\Hom[3]{#1\!\left[#2,\,#3\right]}

\newcommand\Rename[3]{%
  \left\{#1\, /\, #2\right\}#3%
}

\newcommand\Subst[3]{%
  \left[#1\, /\, #2\right]#3%
}

\newcommand\IsSubst[4]{%
  \Subst{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}%
  \leadsto\OMode{#4}%
}

\newcommand\IsEq[2]{\IMode{#1} = \IMode{#2}}
\newcommand\IsApart[2]{\IMode{#1} \mathrel{\#} \IMode{#2}}
\newcommand\IsSubsetEq[2]{\IMode{#1}\subseteq\IMode{#2}}

\newcommand\Define[2]{\IMode{#1}\triangleq\OMode{#2}}
\newcommand\ADefine[2]{\IMode{#1}&\triangleq\OMode{#2}}

\newcommand\SigFun[1]{\mathcal{F}_{#1}}

\newcommand\SemBrackets[1]{\left\llbracket#1\right\rrbracket}
\newcommand\Embed[1]{\left\lfloor#1\right\rfloor}
\newcommand\Yoneda[1]{\boldsymbol{y} (#1)}

\newcommand\Refines[3]{\IMode{#1}\parallel\IMode{#2}\sqsubset\OMode{#3}}
\newcommand\GRefines[2]{\IMode{#1}\sqsubset\OMode{#2}}
\newcommand\RefinesCtx[2]{\IMode{#1}\sqsubset^\star\OMode{#2}}
\newcommand\EqRefines[4]{\IMode{#1}\parallel\IMode{#2}=\IMode{#3}\sqsubset\OMode{#4}}

\newcommand\HRefines[4]{\IMode{#1}\parallel\IMode{#2}\vDash\IMode{#3}\sqsubset\OMode{#4}}
\newcommand\HEqRefines[5]{\IMode{#1}\parallel\IMode{#2}\vDash\IMode{#3}=\IMode{#4}\sqsubset\OMode{#5}}
\newcommand\PRefinesCtx[3]{\IMode{#1}\parallel\IMode{#2}\sqsubset^\star\OMode{#3}}

\newcommand\RMemEq[4]{\IMode{#1}\parallel\IMode{#2}=\IMode{#3}\in\IMode{#4}}
\newcommand\HRMemEq[5]{\IMode{#1}\parallel\IMode{#2}\vDash\IMode{#3}=\IMode{#4}\in\IMode{#5}}

\newcommand\Pow[1]{\wp\left(#1\right)}

\newcommand\SubRefines[4]{\IMode{#1}\parallel\IMode{#2}\subseteq\IMode{#3}\sqsubset\OMode{#4}}
\newcommand\TyBase[1]{\mathtt{Base}_{#1}}
\newcommand\TyTop[1]{\top_{#1}}
\newcommand\TyBot[1]{\bot_{#1}}
\newcommand\TyMeet[1]{\cap_{#1}}
\newcommand\TyJoin[1]{\cup_{#1}}

\newcommand\EvalN[5]{\IMode{#1}\parallel\IMode{#4}\Downarrow^{\OMode{#3}}_{\IMode{#2}}\OMode{#5}}
\newcommand\Eval[4]{\EvalN{#1}{#2}{}{#3}{#4}}
\newcommand\Exprs{\mathbf{E}}
\newcommand\Values{\mathbf{V}}
\newcommand\BTms{\mathbf{B}}
\newcommand\Naturals{\mathbb{N}}
\newcommand\NaturalsPsh{\mathcal{N}}

\tikzset{
  commutative diagrams/.cd,
  arrow style = tikz,
  diagrams = {>=latex},
}
\tikzstyle{displays} = [
  ->,
  >=open triangle 45,
]

\begin{document}

\title{Type Refinements for the Working Class}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

There are two conflicting views which bedevil any discussion of the nature of
type theory. First, there is the notion of type theory as an extension or
generalization of universal algebra to support interdependency of sorts and
operations, possibly subject to an arbitrary equational theory
\cite{cartmell:1986, dybjer:1996}; we will call this \emph{formal type theory}.
Typing, in such a setting, is a mere matter of grammar and is nearly always
decidable. In hindsight, we may observe that this is the sort of type theory
which Martin-L\"of first proposed in 1972~\cite{martin-lof:1972}, even if we
will admit that this was not the intention at the time. A model for such a type
theory is usually given by interpreting the types or sorts as presheaves or
sheaves over contexts of hypotheses, and as such, a proof theoretic
interpretation of the hypothetical judgment is inevitable.

Secondly, there is the view of type theory as semi-formal theory of
constructions for the Brouwer-Heyting-Kolmogorov interpretation of
intuitionistic mathematical language, which we will call \emph{behavioral} or
\emph{semantic type theory}. The most widely known development of this program
is Martin-L\"of's 1979 ``extensional'' type theory~\cite{martin-lof:1979,
martin-lof:1984}, but we must give priority to Dana Scott for inventing this
line of research in 1970 with his prophetic report, \emph{Constructive
Validity}~\cite{scott:1970}. Since the 1980s, behavioral type theory has been
developed much further in the Nuprl family~\cite{constable:1986} of proof
assistants, including MetaPRL~\cite{hickey:2003} and JonPRL~\cite{jonprl:2015}.

Martin-L\"of's key innovation was the commitment to pervasive functionality
(extensionality) as part of the \emph{definitions} of the judgments and the
types, in contrast to the state of affairs in formal type theory where
functionality is a metatheorem which must be shown to obtain, based on the
(somewhat arbitrary) equational theory which has been imposed. Furthermore,
models for behavioral type theory interpret the types as partial equivalence
relations on only closed terms, and the meaning of the hypothetical judgment is
defined separately and uniformly in the logical relations style.

Our position is that these views of type theory are not in conflict, but rather
merely describe two distinct layers in a single, harmonious system. From this
perspective, formal type theories can do little more than negotiate matters of
grammar, and therefore may serve as a syntactic (linguistic) framework
for mathematical language, being responsible for the management of variable
binding and substitution. On the other hand, the meaning of mathematical
statements shall be specified \emph{behaviorally} in the semantic type
theory.

The types of the semantic theory can then be said to \emph{refine} the types of
the syntactic theory~\cite{harper-davies:2014, harper-duff:2015, harper:2016},
both by placing restrictions on membership and by coarsening equivalence. Thus
far, all developments of behavioral type theory have been built on a
\emph{unityped} syntactic framework, and so the relation to type refinements
has been difficult to see. In this paper, we contribute a full theory of
behavioral refinements over multi-sorted abstract binding trees, a simple
formal type theory~\cite{harper:2016, sterling-morrison:2015}; this hybrid
system allows the deployment of a Nuprl-style type theory over any signature of
sorts and operators.

\section{Abstract Binding Trees and Symbols}

See~\cite{sterling-morrison:2015} for the development of abstract binding trees
with symbols. \todo[inline]{give a brief description of the framework, and present its
rules.}

\section{The Ambient Judgmental Framework}
\label{section:ambient-lf}

\ifcolored%
In this paper, we hint at the \emph{modes} of judgments and
assertions~\cite{harper:2016} using colors, marking inputs with
$\IMode{\texttt{blue}}$ and outputs with $\OMode{\texttt{red}}$. As a rule of
thumb, inputs are things which are supplied when checking the correctness of a
judgment, and outputs are things which are synthesized in the process. \fi

For any abt signature $\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$, we can
deploy a generic judgmental framework equipped with higher-order judgments. A
judgment is always defined using a \emph{meaning explanation}, which is a
specification of the conditions under which it may be asserted (sc.\ its
evidence) \cite{martin-lof:1996}.

\paragraph{Renaming convention} Because the evidence of a judgment will often
contain symbols $u,v,\dots$ we informally adopt the convention that the
evidence of a judgment shall always be subject to fresh renamings of its free
symbols (i.e.\ the validity of a judgment shall not depend on choice of names).
This apparatus is developed formally in Appendix~\ref{appendix:lf}, where the
judgmental framework is cast as a topos of covariant presheaves on symbol contexts
$\SCtx$.

\begin{definition}[Hypothetical Judgment]
  For two judgments $\mathcal{J}_1$ and $\mathcal{J}_2$, we can form the
  hypothetical judgment $\HypJ{\mathcal{J}_2}{\mathcal{J}_1}$, whose evidence
  shall be an effective transformation of any evidence for $\mathcal{J}_1$ into
  evidence for $\mathcal{J}_2$. It is important to keep in mind that this is a
  \emph{semantic} consequence and therefore expresses admissibilities, in
  contrast to the \emph{logical} consequence which expresses
  derivabilities~\cite{harper:2016}. We will not have any need for the latter.

  \paragraph{Notation}
  For a hypothetical judgment with multiple hypotheses, we will write
  $\HypJ{\mathcal{J}_3}{\mathcal{J}_1, \mathcal{J}_2}$ rather than
  $\HypJ{\mathcal{J}_3}{\mathcal{J}_1\times\mathcal{J}_2}$ or
  $\HypJ{(\HypJ{\mathcal{J}_3}{\mathcal{J}_2})}{\mathcal{J}_1}$.
\end{definition}

\begin{definition}[General Judgment]
  For a metavariable context $\IsMetaCtx{\Theta}$, we can define the set
  of its substitutions as follows:
  \[
    \Define{{\square\Theta}}{
      \prod_{(\MV{m}:v)\in\Theta}
        \MkSet{E\mid\IsAbtUnmoded{\cdot}{\cdot}{\cdot}{E}{v}}
    }
  \]

  For any $\square{\Theta}$-indexed family of judgments $\mathcal{J}$, we can
  express the general judgment $\GenJ{\Theta}{\mathcal{J}}$ as being evident
  when $\mathcal{J}(\vec{E})$ is evident for each
  $\Of{\vec{E}}{\square\Theta}$; in other words, the evidence of the general
  judgment is an effective transformation of $\Theta$-substitutions to their
  fibres in $\mathcal{J}$.  Recall that metavariables have \emph{valences}
  rather than sorts; as such, the general judgment allows us to quantify over
  terms of higher type.

   \paragraph{Notation}

   We will write $\HPGenJ{\Upsilon}{\Gamma}{\Theta}{\mathcal{J}}$ for
   $\GenJ{\Theta'}{\mathcal{J}}$, where
   $\Lookup{\Theta'}{\MV{m}}{\MkValence{\Upsilon,\vec{\sigma}}{\Gamma,\vec{\tau}}{\tau}}$
   if $\Lookup{\Theta}{\MV{m}}{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}$.
   Additionally, for clarity we will often write
   $\GenJ{\MV{m}:\sigma}{\mathcal{J}}$ rather than
   $\GenJ{\MV{m}:\MkValence{\cdot}{\cdot}{\sigma}}{\mathcal{J}}$; likewise, in
   the body of $\mathcal{J}$, when there are contextually salient
   $\vec{u}$, $\vec{x}$, we will simply write $\MV{m}$ rather than the more proper
   $\MApp{\MV{m}}{\vec{u}}{\vec{x}}$.

\end{definition}

After this section, we will define a judgment either by rules, or by an
informal semantical explanation, in both cases leaving its intensional
character implicit. A judgment is said to be \emph{correct} or \emph{valid}
just in case it is globally inhabited.

\section{Behavioral Refinements}

Fixing a signature $\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$ in the abt
framework, we will define the notion of behavioral refinement by propounding
several judgments and their semantical explanations. Let us first define the
presheaf of $\tau$-sorted expressions, $\Exprs_\tau$ as follows
\[
  \Define{
    \Exprs_\tau(\Upsilon\parallel\Gamma)
  }{
    \MkSet{M \mid \IsAbtUnmoded{\cdot}{\Upsilon}{\Gamma}{M}{\tau}}
  }
\]

We will also write $\Exprs_\tau$ for the presheaf $\Exprs_\tau(-\parallel\cdot)$ on $\SCtx$.

\subsection{Parametric Refinement}

The first judgment that will concern us is called \emph{parametric refinement},
$\Refines{\Upsilon}{\phi}{\tau}$, which means that $\phi$ refines the sort
$\tau$ under the symbolic parameters $\Upsilon$. We define this judgment
through a meaning explanation in the style of Martin-L\"of as follows:

\newcommand\RefEquate[4]{#1\{\IMode{#2}\}\left(\IMode{#3},\IMode{#4}\right)}

\begin{definition}
  To know $\Refines{\Upsilon}{\phi}{\tau}$ (presupposing $\IsSymCtx{\Upsilon}$
  and $\IsSort{\tau}$) is to know, for any $\Of{\rho}{\Upsilon\inj\Upsilon'}$,
  what it means for any $\Member{M,N}{\Exprs_\tau(\Upsilon')}$ to be equated by
  $\phi$ (written $\RefEquate{\phi}{\rho}{M}{N}$), such that
  $\RefEquate{\phi}{\rho}{\cdot}{\cdot}$ is a partial equivalence relation on
  $\Exprs_\tau(\Upsilon')$. Morever, that for any
  $\Of{\rho'}{\Upsilon'\inj\Upsilon''}$, from $\RefEquate{\phi}{\rho}{M}{N}$ we
  may conclude $\RefEquate{\phi}{\rho'\circ\rho}{M\rho'}{N\rho'}$.
\end{definition}

Then, we say that $\phi$ \emph{globally refines} $\tau$ (written
$\GRefines{\phi}{\tau}$) when for all $\Upsilon$, we have
$\Refines{\Upsilon}{\phi}{\tau}$.

\begin{remark}

  At this point, it should be noted that this is very similar to the semantical
  explanation of typehood given in \cite{martin-lof:1979}, except that we have
  generalized it to a multi-sorted setting, and that we have fibred the entire
  apparatus over collections $\Upsilon$ of symbols.

  In fact, the complexity of the above meaning explanation is an artifact of
  the pointwise style in which we have expressed it. Considered internally to
  the presheaf topos $\Sets^\SCtx$, a refinement is merely a section of the
  object of $\Exprs_\tau$-PERs $\mathfrak{per}(\Exprs_\tau)$, defined
  internally as a subobject of $\Omega^{\Exprs_\tau\times\Exprs_\tau}$:
  \[
    \Define{
      \mathfrak{per}(X)
    }{
      \{ \phi : \Omega^{X\times X}
         \mid
         symmetric(\phi)
         \land transitive(\phi)
      \}
    }
  \]

  So, $\Refines{\Upsilon}{\phi}{\tau}$ obtains just when we have
  $\Member{\phi}{\mathfrak{per}(\Exprs_\tau)(\Upsilon)}$. The benefit of
  explaining such judgments in terms of the presheaf topos is that we do not
  need to deal with the complexities of quantifying over renamings, since this
  is implicit in the definition of the exponential of presheaves,
  \begin{align*}
    \ADefine{
      B^A(\Upsilon)
    }{
      \Hom{\Sets^\SCtx}{
        \Yoneda{\Upsilon}\times A
      }{
        B
      }
    }\\
    &\cong
    \OMode{
      \int_{\Upsilon'}
      (\Upsilon\inj\Upsilon')
      \Rightarrow
      {B(\Upsilon')}^{A(\Upsilon')}
    }
  \end{align*}

\end{remark}

\todo[inline]{%
  Restore definitions of the refinement framework after they have been fixed!!
}

%% \subsection{Parametric Refinement}
%%
%% We will require two judgments, defined mutually: $\RefinesCtx{\Phi}{\Upsilon}$,
%% which means that $\Phi$ is a symbol context which refines the symbol context
%% $\Upsilon$ (presupposing $\IsSymCtx{\Upsilon}$), and parametric refinement
%% $\Refines{\Phi}{\phi}{\tau}$ (which shall presuppose
%% $\RefinesCtx{\Phi}{\Upsilon}$ and $\IsSort{\tau}$).
%%
%% \newcommand\RefinesCtxNil{\sqsubset^\star_{\mathtt{nil}}}
%% \newcommand\RefinesCtxSnoc{\sqsubset^\star_{\mathtt{snoc}}}
%%
%% The first judgment we define inductively:
%% \begin{gather*}
%%   \infer[\RefinesCtxNil]{
%%     \RefinesCtx{\cdot}{\cdot}
%%   }{
%%   }\qquad
%%   \infer[\RefinesCtxSnoc]{
%%     \RefinesCtx{\Phi,u:\phi}{\Upsilon,u:\tau}
%%   }{
%%     \RefinesCtx{\Phi}{\Upsilon} &
%%     \Refines{\Phi}{\phi}{\tau}
%%   }
%% \end{gather*}
%%
%% The second judgment is defined coinductively via the following meaning
%% explanation:
%% \begin{definition}[Parametric Refinement]
%%   To know $\Refines{\Phi}{\phi}{\tau}$ (presupposing
%%   $\RefinesCtx{\Phi}{\Upsilon}$ and $\IsSort{\tau}$) is to know, for any renaming
%%   $\Of{\varrho}{\Upsilon\inj\OMode{\Upsilon'}}$, and for any $M, N$,
%%   what it means for $M$ and $N$ to be identified under $\phi$, supposing
%%   $\IsAbt{\cdot}{\Upsilon'}{\cdot}{M}{\tau}$ and
%%   $\IsAbt{\cdot}{\Upsilon'}{\cdot}{N}{\tau}$, requiring that if
%%   $\IMode{M}\sim^\rho_\phi\IMode{N}$ then $\IMode{N}\sim^\rho_\phi\IMode{M}$, and if
%%   $\IMode{M}\sim^\rho_\phi\IMode{N}$ and $\IMode{N}\sim^\rho_\phi\IMode{O}$, then
%%   $\IMode{M}\sim^\rho_\phi\IMode{O}$.
%% \end{definition}
%%
%% In other words, to know $\Refines{\Phi}{\phi}{\tau}$ (presupposing
%% $\RefinesCtx{\Phi}{\Upsilon}$) is to know, for any renaming of $\Upsilon$ to
%% $\Upsilon'$, which partial equivalence relation on the closed $\tau$-sorted
%% $\Upsilon'$-terms $\phi$ denotes. At this point, it should be remarked that
%% this is very similar to the semantical explanation of typehood given in
%% \cite{martin-lof:1979}, except that we have generalized it to a multi-sorted
%% setting, and that we have fibred the entire apparatus over collections
%% $\Upsilon$ of symbols.
%%
%% \todo[inline]{%
%%   define maps of refined contexts, then change weakening lemma to
%%   monotonicity, which is stronger and more useful.
%% }
%% \begin{thm}[Weakening]
%%   If $\Refines{\Phi}{\phi}{\tau}$, then $\Refines{\Phi,u:\psi}{\phi}{\tau}$ (supposing
%%   $\NotIn{u}{\Dom\Phi}$ and $\Refines{\Phi}{\psi}{\sigma}$).
%% \end{thm}
%% \begin{proof}
%%   This follows trivially from the rule $\RefinesCtxSnoc$ and the canonical renaming
%%   $\Upsilon\inj\Upsilon,u:\sigma$.
%% \end{proof}
%%
%% When we have $\Refines{\cdot}{\phi}{\tau}$, we say that $\phi$ \emph{globally}
%% refines $\tau$ and may simply write $\GRefines{\phi}{\tau}$. By weakening, if
%% $\GRefines{\phi}{\tau}$ then for all $\Phi$, we have
%% $\Refines{\Phi}{\phi}{\tau}$ supposing $\RefinesCtx{\Phi}{\Upsilon}$.
%%
%% \subsubsection{Ordering and Equality of Parametric Refinement}
%%
%% We will write $\SubRefines{\Phi}{\phi}{\psi}{\tau}$ to mean that $\phi$ is a
%% \emph{subrefinement} of $\psi$, presupposing $\RefinesCtx{\Phi}{\Upsilon}$,
%% $\Refines{\Upsilon}{\phi}{\tau}$ and $\Refines{\Upsilon}{\psi}{\tau}$:
%% \begin{definition}
%%   To know $\SubRefines{\Phi}{\phi}{\psi}{\tau}$ is to know, for any substitution
%%   $\Of{\rho}{\Upsilon\inj\OMode{\Upsilon'}}$, the following judgments:
%%   \[
%%     \GenJ{
%%       \MV{m},\MV{n}:\tau
%%     }{
%%       \HypJ{
%%         \IMode{M}\sim^\rho_\psi\IMode{N}
%%       }{
%%         \IMode{M}\sim^\rho_\phi\IMode{N}
%%       }
%%     }
%%   \]
%% \end{definition}
%%
%% Two refinements are equal when they denote the same PER. That is, we have
%% $\EqRefines{\Phi}{\phi}{\psi}{\tau}$ just when both
%% $\SubRefines{\Phi}{\phi}{\psi}{\tau}$ and $\SubRefines{\Phi}{\psi}{\phi}{\tau}$.
%%
%% \subsection{Parametric Equality}
%%
%% The primary judgment concerning refinements is the parametric equality,
%% $\RMemEq{\Phi}{M}{N}{\phi}$, which presupposes $\RefinesCtx{\Phi}{\Upsilon}$,
%% $\Refines{\Phi}{\phi}{\tau}$, $\IsAbt{\cdot}{\Upsilon}{\cdot}{M}{\tau}$ and
%% $\IsAbt{\cdot}{\Upsilon}{\cdot}{N}{\tau}$. The meaning of this judgment is that
%% $M$ and $N$ are identified by $\phi$ at the identity renaming
%% $\Of{1}{\IMode{\Upsilon}\inj\OMode{\Upsilon}}$:
%% \[
%%   \infer{
%%     \RMemEq{\Phi}{M}{N}{\phi}
%%   }{
%%     \IMode{M}\sim^1_\phi\IMode{N}
%%   }
%% \]
%%
%% \subsection{Functional Refinement}
%%
%% \newcommand\PRefinesCtxNil{\leftidx{^\parallel}{\!\!\sqsubset}{^\star_{\mathtt{nil}}}}
%% \newcommand\PRefinesCtxSnoc{\leftidx{^\parallel}{\!\!\sqsubset}{^\star_{\mathtt{snoc}}}}
%%
%% Next, we define functional refinement
%% $\HEqRefines{\Phi}{\Psi}{\phi}{\psi}{\tau}$ in terms of parametric refinement,
%% simultaneously with parametric context refinement
%% $\PRefinesCtx{\Phi}{\Psi}{\Gamma}$ and functional equality
%% $\HRMemEq{\Phi}{\Psi}{M}{N}{\phi}$. We will write
%% $\HRefines{\Phi}{\Psi}{\phi}{\tau}$ as a shorthand for
%% $\HEqRefines{\Phi}{\Psi}{\phi}{\phi}{\tau}$.
%%
%% \newcommand\DefPRefinesCtxNil[1]{
%%   \infer[\PRefinesCtxNil]{
%%     \PRefinesCtx{#1}{\cdot}{\cdot}
%%   }{
%%   }
%% }
%% \newcommand\DefPRefinesCtxSnoc[6]{
%%   \infer[\PRefinesCtxSnoc]{
%%     \PRefinesCtx{#1}{#2,#3:#4}{#5,#3:#6}
%%   }{
%%     \PRefinesCtx{#1}{#2}{#5} &
%%     \HRefines{#1}{#2}{#4}{#6}
%%   }
%% }
%%
%% Parametric context refinement $\PRefinesCtx{\Phi}{\Psi}{\Gamma}$ shall be
%% defined as follows, presupposing $\RefinesCtx{\Phi}{\Upsilon}$ and
%% $\IsVarCtx{\Gamma}$:
%% \begin{gather*}
%%   \DefPRefinesCtxNil{\Phi}\qquad
%%   \DefPRefinesCtxSnoc{\Phi}{\Psi}{x}{\phi}{\Gamma}{\tau}
%% \end{gather*}
%%
%% Functional refinement $\HEqRefines{\Phi}{\Psi}{\phi}{\psi}{\tau}$ presupposes
%% $\PRefinesCtx{\Phi}{\Psi}{\Gamma}$ and $\IsSort{\tau}$, and is explained by
%% induction on the evidence for its first presupposition.
%%
%% \paragraph{Case} $\DefPRefinesCtxNil{\Phi}$.
%% \[
%%   \infer{
%%     \HEqRefines{\Phi}{\cdot}{\phi}{\psi}{\tau}
%%   }{
%%     \EqRefines{\Phi}{\phi}{\psi}{\tau}
%%   }
%% \]
%%
%% \paragraph{Case} $\DefPRefinesCtxSnoc{\Phi}{\Psi}{x}{\chi}{\Gamma}{\sigma}$,
%% where $\RefinesCtx{\Phi}{\Upsilon}$.
%%
%% \begin{gather*}
%%   \infer{
%%     \HEqRefines{\Phi}{\Psi,x:\chi}{\phi}{\psi}{\tau}
%%   }{
%%     \HPGenJ{\Upsilon}{\Gamma}{\MV{m},\MV{n}:\sigma}{
%%       \HypJ{
%%         \HEqRefines{\Phi}{\Psi}{
%%           \Subst{\MV{m}}{x}{\phi}
%%         }{
%%           \Subst{\MV{n}}{x}{\psi}
%%         }{\tau}
%%       }{
%%         \HRMemEq{\Phi}{\Psi}{\MV{n}}{\MV{n}}{\chi}
%%       }
%%     }
%%   }
%% \end{gather*}
%%
%% \subsection{Functional Equality}
%%
%% Functional equality $\HRMemEq{\Phi}{\Psi}{M}{N}{\phi}$ presupposes
%% $\RefinesCtx{\Phi}{\Upsilon}$, $\PRefinesCtx{\Phi}{\Psi}{\Gamma}$,
%% $\HRefines{\Phi}{\Psi}{\phi}{\tau}$, $\IsAbt{\cdot}{\Upsilon}{\Gamma}{M}{\tau}$
%% and $\IsAbt{\cdot}{\Upsilon}{\Gamma}{N}{\tau}$; the judgment is defined by
%% induction on the evidence for the second presupposition
%% $\PRefinesCtx{\Phi}{\Psi}{\Gamma}$:
%%
%% \paragraph{Case} $\DefPRefinesCtxNil{\Phi}$.
%% \[
%%   \infer{
%%     \HRMemEq{\Phi}{\cdot}{M}{N}{\phi}
%%   }{
%%     \RMemEq{\Phi}{M}{N}{\phi}
%%   }
%% \]
%%
%% \paragraph{Case} $\DefPRefinesCtxSnoc{\Phi}{\Psi}{x}{\psi}{\Gamma}{\sigma}$,
%% where $\RefinesCtx{\Phi}{\Upsilon}$.
%% \[
%%   \infer{
%%     \HRMemEq{\Phi}{\Psi,x:\psi}{M}{N}{\phi}
%%   }{
%%     \HPGenJ{\Upsilon}{\Gamma}{\MV{m},\MV{n}:\sigma}{
%%       \HypJ{
%%         \HRMemEq{\Phi}{\Psi}{
%%           \Subst{\MV{m}}{x}{\phi}
%%         }{
%%           \Subst{\MV{n}}{x}{\psi}
%%         }{\phi}
%%       }{
%%         \HRMemEq{\Phi}{\Psi}{\MV{m}}{\MV{n}}{\psi}
%%       }
%%     }
%%   }
%% \]
%%
%% \section{Constructions on Refinements}
%%
%% Refinements can be arranged in a partial order via the
%% $\SubRefines{\Phi}{\phi}{\psi}{\tau}$ judgment, and admit a lattice structure
%% at any sort $\tau$.
%%
%% We have the bottom refinement $\GRefines{\TyBot{\tau}}{\tau}$, which simply
%% contains no elements. Next, the top refinement $\GRefines{\TyTop{\tau}}{\tau}$
%% identifies all terms $M,N$ such that $\IsAbt{\cdot}{\Upsilon}{\cdot}{M}{\tau}$
%% and $\IsAbt{\cdot}{\Upsilon}{\cdot}{N}{\tau}$. The join
%% $\Refines{\Phi}{\phi\TyJoin{\tau}\psi}{\tau}$ of two refinements
%% $\Refines{\Phi}{\phi}{\tau}$ and $\Refines{\Phi}{\psi}{\tau}$ is defined as follows:
%% \begin{gather*}
%%   \infer{
%%     \RMemEq{\Phi}{M}{N}{\phi\TyJoin{\tau}\psi}
%%   }{
%%     \RMemEq{\Phi}{M}{N}{\phi}
%%   }\qquad
%%   \infer{
%%     \RMemEq{\Phi}{M}{N}{\phi\TyJoin{\tau}\psi}
%%   }{
%%     \RMemEq{\Phi}{M}{N}{\psi}
%%   }
%% \end{gather*}
%%
%% Finally the meet $\Refines{\Phi}{\phi\TyMeet{\tau}\psi}{\tau}$ of two refinements
%% $\Refines{\Phi}{\phi}{\tau}$ and $\Refines{\Phi}{\psi}{\tau}$ is defined
%% dually:
%% \[
%%   \infer{
%%     \RMemEq{\Phi}{M}{N}{\phi\TyMeet{\tau}\psi}
%%   }{
%%     \RMemEq{\Phi}{M}{N}{\phi} &
%%     \RMemEq{\Phi}{M}{N}{\psi}
%%   }
%% \]
%%
%% It is trivial to verify that these constructions on refinements give rise to a
%% lattice.
%%
%% \section{Multi-Sorted Computational Type Theory}
%%
%% Martin-L\"of's type theory is a theory of \emph{value types}: to define a type,
%% you specify how to form its equal canonical inhabitants, or values. Then, the
%% inhabitants of the types are explained uniformly by extending this relation
%% over an operational semantics such that two terms are equal members of a
%% type just when they compute to equal values of that type.
%%
%% More generally, one may wish to consider types which include computations in
%% addition to values; an example of such a type would be $\bar{\psi}$ when $\psi$
%% is a type, which would include all the members of $\psi$ as well as a divergent
%% computation. Another example is the type $\TyTop{\tau}$ which identifies all
%% closed terms of sort $\tau$.
%%
%% In order to ensure that such types are sensible, we must formulate a notion of
%% computational equivalence, and then say that a refinement is a \emph{type} just
%% when it respects computational equivalence; then, we are able to define types
%% as PERs on \emph{programs} in addition to values.


\subsection{Lazy Computation Systems}

In this section we generalize Howe's notion of lazy computation
system~\cite{howe:1989} to the multi-sorted, symbol-parameterized setting. An
\emph{lazy computation language} is an abt signature
$\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$ along with a distinguished
copresheaf $\Of{\CanOperators}{\Sets^{\SCtx\times\Discrete{\Arities}}}$ of
\emph{canonical} operators such that $\IsSubsetEq{\CanOperators}{\Operators}$.
For a lazy computation language
$\Match{L}{\Tuple{\Sorts,\Operators,\CanOperators}}$, let us define the
covariant presheaves on $\SCtx\times\Ctx$ of open expressions, open values, and open bound terms
as follows:
\begin{align*}
  \ADefine{\Exprs_\tau(\Upsilon\parallel\Gamma)}{
    \MkSet{M \mid \IsAbtUnmoded{\cdot}{\Upsilon}{\Gamma}{M}{\tau}}
  }\\
  \ADefine{\Values_\tau(\Upsilon\parallel\Gamma)}{
    \MkSet{
      M\equiv\App{\vartheta}{\vec{E}}
      \mid M\in\Exprs_\tau(\Upsilon\parallel\Gamma)\land \exists a. \CanOperators\Pair{\Upsilon}{a}\ni\vartheta
    }
  }\\
  \ADefine{
    \BTms_{v}(\Upsilon\parallel\Gamma)
  }{
    \MkSet{E \mid \IsAbtUnmoded{\cdot}{\Upsilon}{\Gamma}{E}{v}}
  }
\end{align*}

We'll write $\Exprs_\tau(\Upsilon)$, $\Values_\tau(\Upsilon)$ and
$\BTms_v(\Upsilon)$ for $\Exprs_\tau(\Upsilon\parallel\cdot)$,
$\Values_\tau(\Upsilon\parallel\cdot)$ and $\BTms_v(\Upsilon\parallel\cdot)$
respectively, viewed as covariant presheaves on $\SCtx$. Then, a \emph{lazy
computation system} (lcs) is a lazy computation language
$\Match{L}{\Pair{\Sigma}{\CanOperators}}$ along with an $\SCtx$-indexed
$\equiv_\alpha$-functional evaluation relation
$\EvalN{\Upsilon}{\tau}{n}{M}{N}$ presupposing $\Member{n}{\Naturals}$,
$\Member{M}{\Exprs_\tau(\Upsilon)}$ and $\Member{N}{\Values_\tau(\Upsilon)}$,
expressing that $M$ evaluates to $N$ in $n$ steps.  We will write
$\Eval{\Upsilon}{\tau}{M}{N}$ to mean that there exists an $n$ such that
$\EvalN{\Upsilon}{\tau}{n}{M}{N}$.

\begin{remark}
  In any topos $\mathcal{E}$, for an object $X$ we can define the object of
  relations on $X$ as the exponential $\Define{\Pow{X}}{\Omega^X}$. Then, the
  data of such a relation is contained in a natural transformation
  $\Of{R}{\Hom{\mathcal{E}}{\mathbb{1}}{\Pow{X}}}$.
\end{remark}

\newcommand\SBinRel[4]{\IMode{#2}\parallel\IMode{#3}\mathrel{#1}\IMode{#4}}

Fix a sort-indexed family of binary relations on closed expressions
$\Of{R_\tau}{\Hom{\Sets^{\SCtx}}{\mathbb{1}}{\Pow{\Exprs_\tau^2}}}$; we will
also write the relation as a judgment scheme
$\SBinRel{R_\tau}{\Upsilon}{M}{N}$. Now, we can always extend $R_\tau$ to a new
family of relations
$\Of{R_v}{\Hom{\Sets^{\SCtx}}{\mathbb{1}}{\Pow{\BTms_v^2}}}$ for any valence
$\Match{v}{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}$, defined pointwise as
follows:
\[
  \infer{
    \SBinRel{R_{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}}{\Upsilon}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{v}}{\vec{y}}{N}
    }
  }{
    \begin{array}{l}
      \forall\IMode{\vec{w}}\mathrel{\#}\IMode{\Dom{\Upsilon}\cup\vec{u}\cup\vec{v}}.\quad
      \forall\Of{\vec{X}}{\Exprs_\tau^{[\vec{\tau}]}(\Upsilon,\vec{w}:\vec{\sigma})}.\\
      \SBinRel{R_\tau}{\Upsilon,\vec{w}:\vec{\sigma}}{
        \Subst{\vec{X}}{\vec{x}}{\Rename{\vec{w}}{\vec{u}}{M}}
      }{
        \Subst{\vec{X}}{\vec{y}}{\Rename{\vec{w}}{\vec{v}}{N}}
      }
    \end{array}
  }
\]

As a matter of convenience, we'll also define this judgment over vectors of bound terms and valences:
\[
  \infer{
    \SBinRel{R_{\vec{v}}}{\Upsilon}{\vec{E}}{\vec{F}}
  }{
    \forall\Member{(E,F,v)}{(\vec{E},\vec{F},\vec{v})}.\
    \SBinRel{R_v}{\Upsilon}{E}{F}
  }
\]

Now, we can extend $R_\tau$ to a new relation $[R_\tau]$ on closed expressions
which respects a single ``layer'' of computation. We will say
$\SBinRel{[R_\tau]}{\Upsilon}{M}{N}$ when, supposing
$\Eval{\Upsilon}{\tau}{M}{\App{\vartheta}{\Vec{E}}}$ such that
$\IMode{\Upsilon}\Vdash_{\IMode{\CanOperators}}\IMode{\vartheta}:\OMode{\MkArity{\vec{v}}{\tau}}$,
for any $\Of{\rho}{\Upsilon\inj\Upsilon'}$, we have
$\Eval{\Upsilon'}{\tau}{N\rho}{\App{\vartheta\rho}{\Vec{F}\rho}}$ and
$\SBinRel{R_{\vec{v}}}{\Upsilon'}{\vec{E}\rho}{\vec{F}\rho}$.

\begin{definition}[Computational Approximation]
Because $[-_\tau]$ is monotonic, it has a greatest fixed point, which we will
call \emph{computational approximation},
$\Of{\preccurlyeq_\tau}{\Hom{\Sets^\SCtx}{\mathbb{1}}{\Pow{\Exprs_\tau^2}}}$,
written pointwise as $\SBinRel{\preccurlyeq_\tau}{\Upsilon}{M}{N}$.
\end{definition}

\begin{definition}[Computational Equivalence]
  Two terms are said to be \emph{computationally equivalent} when they approximate each other:
  \[
    \infer{
      \SBinRel{\sim_\tau}{\Upsilon}{M}{N}
    }{
      \SBinRel{\preccurlyeq_\tau}{\Upsilon}{M}{N} &
      \SBinRel{\preccurlyeq_\tau}{\Upsilon}{N}{M}
    }
  \]
\end{definition}

%%% Now, let us consider relations on open terms; in general, it will be easiest
%%% for us to situate our constructions on relations in the presheaf topos
%%% $\Define{\widehat{\HypCat}}{\Sets^{\SCtx\times\Ctx}}$. Then, for any two
%%% objects objects $\Of{X,Y}{\widehat{\HypCat}}$, we can form the object of
%%% relations between them as $\Define{\Pow{X\times Y}}{\Omega^{X\times Y}}$.
%%%
%% . A binary relation $R_\tau$
%% between open expressions of sort $\tau$ can be thought of as a global section
%% of the exponential object
%% $\Match{\Pow{\Exprs_\tau\times\Exprs_\tau}}{\Omega^{\Exprs_\tau\times\Exprs_\tau}}$
%% of the presheaf topos $\Define{\widehat{\HypCat}}{\Sets^{\SCtx\times\Ctx}}$

\newpage
\begin{appendices}
\section{Formal Definition of the Judgmental Framework}
\label{appendix:lf}

As noted earlier, we must be cautious in the definitions of both atomic and
higher-order judgments that their evidence shall always respect the
\emph{renaming convention}. We do so explicitly in this appendix by developing
our judgmental framework as a presheaf topos over symbol contexts.

A judgment is, then, an object in the presheaf category
$\Define{\mathbb{J}}{\Sets^\SCtx}$; in other words, judgments are identified
with the intensional set of its renameable evidence. $\mathbb{J}$, like all
presheaf categories, is a topos. The task at hand, then, is to show how to
replace the informal meaning explanations that we gave in
section~\ref{section:ambient-lf} with precise definitions in the topos
$\mathbb{J}$.

\subsection{Hypothetical Judgment}

Hypothetical judgment $\HypJ{\mathcal{J}_2}{\mathcal{J}_1}$ is defined using the
exponential construction~\cite[p.~46]{maclane-moerdijk:1992}, which expresses
the semantic consequence of $\mathcal{J}_2$ from $\mathcal{J}_1$:
\begin{align*}
  \ADefine{
    \left(\HypJ{\mathcal{J}_2}{\mathcal{J}_1}\right)(\Upsilon)
  }{
    \left({\mathcal{J}_2}^{\mathcal{J}_1}\right)(\Upsilon)
  }\\
  &\cong
  \OMode{
    \Hom{\mathbb{J}}{
      \Yoneda{\Upsilon}\times\mathcal{J}_1
    }{
      \mathcal{J}_2
    }
  }\\
  &\cong
  \OMode{
    \int_{\Upsilon'}{{\Upsilon\inj\Upsilon'}
      \Rightarrow{{{\mathcal{J}}_{2}(\Upsilon')}^{{\mathcal{J}}_{1}(\Upsilon')}}}
  }
\end{align*}

In other words, the hypothetical judgment $\HypJ{\mathcal{J}_2}{\mathcal{J}_1}$
is evident when there shall ``forevermore'' (i.e. for any applicable renaming
of symbols) be an effective transformation of evidence for the antecedent into
evidence for the consequent.

\subsection{General Judgment}

For any diagram $\Of{\mathcal{J}}{\mathbb{J}^{\square\Theta}}$, we can define
the general judgment $\GenJ{\Theta}{\mathcal{J}}$ as follows:
\begin{align*}
  \ADefine{
    \left(\GenJ{\Theta}{\mathcal{J}}\right)(\Upsilon)
  }{
    \Hom{\mathbb{J}}{
      \Yoneda{\Upsilon}
    }{
      \varprojlim\mathcal{J}
    }
  }\\
  &\cong
  \OMode{
    \int_{(\Upsilon',\,\vec{E})}{\Upsilon\inj\Upsilon'\Rightarrow{\mathcal{J}(\vec{E})(\Upsilon')}}
  }
\end{align*}

 Intuitively, the general judgment $\GenJ{\Theta}{\mathcal{J}}$ is evident
 when the family of judgments $\mathcal{J}$ shall forevermore have a global
 section (i.e.\ for any substitution $\Member{\vec{E}}{\square\Theta}$,
 $\mathcal{J}(\vec{E})$ shall be evident).


\subsection{Internal Judgments}
It often happens that the evidence for a judgment is the knowledge of the
meaning of a new form of judgment; this is the case when we say ``To know
$\mathcal{J}$ is to know \emph{the meaning of} another judgment
$\mathcal{J}'$.'' This can be neatly expressed in our topos using the subobject
classifier $\Omega$, where the evidence of $\Omega$ at $\Upsilon$ gives rise to
an \emph{internal judgment} which is defined at all $\Upsilon'$ for which we
have $\Of{\rho}{\Upsilon\inj\Upsilon'}$.

A \emph{global internal (family of) judgments} is a section
$\Of{J}{\int_\SCtx {\Omega^{\mathcal{J}}}}\cong
\IMode{\int_\Upsilon\Hom{\mathbb{J}}{\Yoneda{\Upsilon}\times\mathcal{J}}{\Omega}}$,
which can be externalized as a ``total'' judgment $\Of{\Embed{J}}{\mathbb{J}}$
for whose derivations at $\Upsilon$ are the arrows
$\Of{\phi}{\Hom{\mathbb{J}}{\Yoneda{\Upsilon}}{\mathbb{1}\times\mathcal{J}}}$
such that the following diagram commutes:
\[
  \begin{tikzcd}[cramped,sep=huge]
    \IMode{\Yoneda{\Upsilon}}
      \arrow[r, dashed, "\OMode{\phi}"]
      \arrow[rd, "\IMode{J_\Upsilon\Pair{1}{\pi_2\circ\phi}}"']
    & \IMode{\mathbb{1}\times\mathcal{J}} \arrow[d, "\IMode{\mathbf{true}\circ\pi_1}"] \\
    & \IMode{\Omega}
  \end{tikzcd}
\]

Then, to say $\IMode{\Upsilon}\parallel\Embed{J}(E)$ where
$\Member{E}{\mathcal{J}(\Upsilon)}$ is to assert that we have evidence
$\Member{F}{\Embed{J}(\Upsilon)}$ such that $\IsEq{\pi_2(F)}{E}$.



\end{appendices}

\ifdraft{}{
  \newpage
  \nocite{maclane:1971}
  \bibliographystyle{abbrv}
  \bibliography{refs}
}


\end{document}
